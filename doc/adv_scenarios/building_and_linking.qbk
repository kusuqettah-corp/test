[/
 / Copyright (c) 2003-2014 Gennadiy Rozental 
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:build_lib Building the __UTF__]

In case you would like to use the shared or static variants of the __UTF__, the library needs to be built. 
Building the __UTF__ is in fact quite easy.

In the sequel, we define

* $`boost_path` refers to the location where the boost archive was deflated
* $`boost_installation_prefix` refers to the location where you want to install the __UTF__

[/ not true
 [note By default, the static and dynamic variant will be built for your operating system]
]

More documentation about Boost's build system can be found [@http://www.boost.org/more/getting_started/index.html here]. 

[h3 Windows]

You need to have a compilation toolchain. /Visual Studio Express/ is such one, freely available from the 
Microsoft website. Once installed, 

[h4 Static variant]
For building 32bits libraries, open a console window and enter the following commands:
```
> cd ``$``boost_path
> boostrap.bat
> b2 address-model=32 architecture=x86 --with-test --link=static \
>                     --prefix=``$``boost_installation_prefix install
```

For building 64bits libraries, the commands become:
```
> cd ``$``boost_path
> boostrap.bat
> b2 address-model=64 architecture=x86 --with-test --link=static \
>                    --prefix=``$``boost_installation_prefix install
```

[h4 Shared library variant]
In order to build the shared library variant, the directive `--link=static` should be replaced by `--link=shared` on the above command lines. 
For instance, for 64bits builds, the commands become:

```
> cd ``$``boost_path
> boostrap.bat
> b2 address-model=64 architecture=x86 --with-test --link=shared --prefix=``$``boost_installation_prefix install
```

[h3 Linux/OSX]
For Unix/Linux/OSX operating system, the build of the __UTF__ is very similar to the one on Windows:
```
> cd ``$``boost_path
> ./boostrap.sh
> ./b2 --with-test --prefix=``$``boost_installation_prefix install
```

[section:build Building a test module with the __UTF__]

There are two tasks should be performed before actual testing is able to start:

* The test tree needs to be built: unless automated test units registration is used, the tests that should be run and their relationship
  should be indicated.
* Custom ['test module initialization] needs to be performed. This includes
  initialization of the code under test and custom tune-up of the __UTF__ parameters (for example the test log or the
  test results report output streams redirection, some command line parameters passed to the test module, etc.).

The part of the __UTF__ dedicated for this purpose is called [link boost_test.adv_scenarios.build_lib.module_initialization ['the test module initialization]] function. 

[note Note that alternatively to ['module initialization], global [link boost_test.users_guide.tests_organization.fixtures fixtures] may be employed.]

The ['module initialization] and the way the test module is linked against the __UTF__ are closely related. The method used to link 
against the __UTF__ are often lead by considerations external to the tests themselves (compilation time, size of the generated binaries, etc). However,
the functions of the ['module initialization] involved in, say static and dynamic linking, will not be the same. To cover many possible usages,
the __UTF__ handles several different variants of linking, and indirectly the tools for proper ['module initialization] corresponding to each
of these variants are provided.

[endsect] [/ building boost test]

[/ ######################################################## ]
[include module_initialization.qbk]

[/ ######################################################## ]
[section:usage_variants Linking with the __UTF__]

The __UTF__ supports four different usage variants:

# The single-header variant: all __UTF__ is contained in header-only source files and there is no particular set-up for linking your test module,
  which makes this configuration very simple.
  While suitable for small set-up contained in an unique file, the compilation of all __UTF__ headers is done per test module, which
  may be rather slow, and the code is duplicated in each compilation unit, which is sometime not desirable as a lot of code may be factorized 
  out in a shared library.
# The static library variant: the code is not compiled in all compilation unit anymore, but since the link is against the static libraries
  of the __UTF__, it also gets duplicated among several test modules.
# The dynamic library variant: this is the most appropriate set-up when you have a lot of test modules, as the redundant code of the __UTF__
  resides in a shared library to which you test module is linked against.
# The external test runner variant

Unlike the Buridan's donkey though, you shouldn't have problems deciding which one to use, since there are
clear reasons why would you prefer each one.

In most cases to compile a test module based on the __UTF__ all you need to include is just the [headerref boost/test/unit_test.hpp single header]

``
  #include <boost/test/unit_test.hpp>
``

This header includes internally most of the other headers that contains the __UTF__ definitions. Some advanced features, 
like the floating point comparison or the logged expectations testing, are defined in independent headers and need to be included explicitly.

[include variant_static_lib.qbk]
[include variant_dynamic_lib.qbk]
[include variant_single_header.qbk]
[include variant_external_runner.qbk]

[endsect] [/section:usage_variants]

[/ ######################################################## ]
[/ reference of the macros]
[include link_reference.qbk]

[endsect] [/section:build]

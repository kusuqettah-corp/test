[/
 / Copyright (c) 2015 Andrzej Krzemienski
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:customizing_entry_point Customizing the module's entry point]

The C++ Standard defines that the executable program's entry point must be called `main`, ant that every conforming compiler has to accept the signature:

```
int main(int argc, char* argv[]);
```

The __UTF__, when you instruct it to do so (e.g. with macro __BOOST_TEST_MODULE__), will define function `main` with the above signature for you. However, sometimes it might be necessary to define a custom entry point with different name, or different signature, or returning a different value to the environment. In that case it is necessary to suppress the automatic definition of function `main`. The __UTF__ allows you to do it. The procedure depends on the usage variant.

[h3:included __UTF__ included]

In this usage variant, in your single translation unit, you need to define macro __BOOST_TEST_NO_MAIN__ (its value is irrelevant) prior to including any of the framework's headers. Next, you have to define your custom entry point, and invoke `unit_test_main` manually with auto-generated module initialization function `init_unit_test` as argument.

[bt_example customize_01..using custom entry point]

In the above example, a custom entry point was selected because the test module, in addition to command line arguments needs to obtain also the information about environment variables. Also, the test module now returns value 0 to the environment regardless of the testing outcome. 

[note The above example also illustrates that it makes sense to define both __BOOST_TEST_MODULE__ and __BOOST_TEST_NO_MAIN__. This way, no `main` is generated by the framework, but the specified name is assigned to the [link boost_test.tests_organization.test_suite.master_test_suite Master Test Suite].]

[note The reason for defining __BOOST_TEST_ALTERNATIVE_INIT_API__ is described [link boost_test.adv_scenarios.customizing_key_components.module_initialization.custom_module_init here]].

[h3:statically_linked __UTF__ statically linked]

In this variant, you need to rebuild the __UTF__ static library with the defined symbol __BOOST_TEST_NO_MAIN__. In the Boost root directory you need to invoke command

```
> b2 --with-test link=static define=__BOOST_TEST_NO_MAIN__ define=__BOOST_TEST_ALTERNATIVE_INIT_API__ install
```

In one of the source files, you now have to define your custom entry point, and invoke `unit_test_main` manually with auto-generated module initialization function `init_unit_test` as argument. There is no need to define __BOOST_TEST_NO_MAIN__ in your source code, but you need to define __BOOST_TEST_ALTERNATIVE_INIT_API__ in the main file:

[table
[[In *exactly one* file][In all other files]]
[[```#define BOOST_TEST_MODULE test module name
#define BOOST_TEST_ALTERNATIVE_INIT_API
#include <boost/test/unit_test.hpp>

// entry point
```]
[```#include <boost/test/unit_test.hpp>

//
// test cases
//
```]]
]

[h3:dynamically_loaded __UTF__ dynamically loaded]

In this variant, in one of the source files, you now have to define your custom entry point, and invoke `unit_test_main` manually with auto-generated module initialization function `init_unit_test` as argument. You need to define __BOOST_TEST_NO_MAIN__ (its value is irrelevant) in the main file:

[table
[[In *exactly one* file][In all other files]]
[[```#define BOOST_TEST_MODULE test module name
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

// entry point
```]
[```#define BOOST_TEST_DYN_LINK
#include <boost/test/unit_test.hpp>

//
// test cases
//
```]]
]

[endsect] [/section:customizing_entry_point]

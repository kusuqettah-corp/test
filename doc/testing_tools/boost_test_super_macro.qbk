[/
 / Copyright (c) 2015 Raffi Enficiaud
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:boost_test_super_macro `BOOST_TEST` or the Swiss Army knife]

Once a test case has been declared, the body of this test should be written. A test case is a 
sequence of operations in which *assertions* are inserted. Those assertions evaluate /statements/ that verify the integrity 
of the pre and post conditions of the operations. There are three kind of assertions, having different meaning on the
consistency of the test case:

* *requirements*: this is a strong condition for the operations following the assertion to be valid. 
  This type of assertions should be used when a pre-condition for the test is not met or when the test-case cannot continue.
  If such as assertion fails, the test case execution stops immediately, and the test-case is flagged as /failed/.
* *checks*: this is the most commonly used assertion level. If the statement evaluates to `false`, the test case is 
  flagged as failed but its execution continues. 
* *warnings*: this is an assertion providing information. The test case execution continues and a warning message is logged. 
  The warning does not change the success status of a test case.
  
These three levels of assertions are reported into the test log and output, as described in details in the 
[link boost_test.users_guide.testing_tools.tools_assertion_severity_level severity levels] section. The granularity of the
report depends on the current [link boost_test.users_guide.runtime_config.rt_param_reference.param_log_level log level] and 
[link boost_test.users_guide.runtime_config.rt_param_reference.param_report_level report level].

A unique interface is given by three variants of the `BOOST_TEST` assertion:

* `BOOST_TEST_REQUIRE`
* `BOOST_TEST_CHECK` or just `BOOST_TEST`
* `BOOST_TEST_WARN`

As their name suggests these assertions are, in order, for /requirement/, /checks/ and /warnings/.

[warning To get all the functionalities of `BOOST_TEST` family of assertions, a C++11 capable compiler is required, especially
 supporting the `auto` and `decltype` keywords and the variadic macros. The documentation focuses on these set of compilers. A 
 limited support is provided for C++03 compilers.]

[section:acceptable_statements Acceptable statements]

The __BOOST_TEST__ assertion uses some tricks with C++ operator overloading in order to perform its magic. This implementation
gives flexibility to __BOOST_TEST__ at the cost of narrowing the supported statements. The unsupported statements are:

* statements containing ternary conditions: those statement should be surrounded by parenthesis as they cannot be overloaded
* statements containing comas: those statements will be intercepted by the preprocessor
* compound statements containing any logical composition `||`, `&&`
  
[bt_example boost_test_macro1..BOOST_TEST acceptable expressions]

An expression chain [footnote which *differs* from an expression tree] is constructed from the statement. 
The chain is built from left to right, combining one binary operation with two operands. The following statements

``
BOOST_TEST(a op1 b op2 c op3 d);
``

# evaluates first `r1` as "`a op1 b`" and determines the resulting type `t1`
# evaluates then `r2` as "`r1 op2 c`" and determines its type
# etc.

All in all, the statement above is seen as 

  ((a op1 b) op2 c) op3 d

which makes the following statement perfectly valid

``
  a == 12 == 42 == b
``

but might not have the desired effect: For instance the result of "`a == 12`" would be `bool`, which in turn evaluates 
"`bool (true or false) == 42`".

[bt_example boost_test_macro2..BOOST_TEST compound statements]

The supported operations may be any of the binary overloadable operations in C++, except logical AND and OR, and COMA:
  
* binary comparisons: `==`, `!=`, `<`, `>`, `<=`, `>=`
* arithmetic and bitwise compositions: `+`, `-`, `*`, `/`, `%`, `|`, `&`, `^`, `<<`, `>>`
* assignements: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `^=`, `|=`

[endsect] [/ acceptable expressions]


[/ ################################################ ]
[section:collections Sequences comparison]

Instead of comparing one singular value against another, there is often the need to compare /sequences/ of values. 
Most of the time, the test for the full sequences is achieves through loops.

__BOOST_TEST__ automatically detects [link what_is_a_sequence /containers/] that provide sequences of elements.
Let's `c_a = (a_1,... a_n)` and `c_b = (b_1,... b_n)` be two containers of same size, but not necessarily of same type, and 
let `op` be one of the [link boost_test.users_guide.testing_tools.boost_test_super_macro.acceptable_statements binary comparison operators].

``
BOOST_TEST(c_a op c_b)
``

is equivalent to

``
bool result(c_a.size() == c_b.size());
if(result) 
{
  for(int i=0; i < c_a.size(); i++)
  {
    __BOOST_TEST_CONTEXT__("index" << i);
    result &= a_i op b_i;
  }
}
BOOST_TEST(result);
``

[warning this is fondamentally different from using the containers' overloaded comparison operators, such as 
 ``bool operator==;``
 The *default* behaviour of __BOOST_TEST__ is to compare elements by elements, in order, the containers in operands. If a test
 of an overloaded operator `comp` is needed, the following syntax *with additional parenthesis* should be used
 
 ``BOOST_TEST((c_a comp c_b))``
 ]

Sequences are compared using the specified operator `op`, evaluated on the left and right elements of the respective sequences,
/in order/.
The order of elements is given by the iterators of the respective containers [footnote the containers should yield the same
sequences for a fixed set of elements they contain]. 
In case of failure, the indices of the elements failing `op` are returned.

[bt_example boost_test_macro_sequence..BOOST_TEST sequence comparison]

[h3 Requirements]
For the sequences to be comparable with __BOOST_TEST__, it is required 

* that they should have the same number of elements
* `op` should be one of the comparison operator `==`, `!=`, `<`, `<=`, `>`, `>=`
* the `a_i op b_i` should be defined, where the type of `a_i` and `b_i` are the type returned by the dereference operator
  of the respective collections:  
  [bt_example boost_test_macro_container_value_type..BOOST_TEST comparison defined on elements]

[caution the resulting type of "`c_a == c_b`" is an [classref boost::test_tools::assertion_result assertion_result]. It is not
 possible to compose more that one comparison on the __BOOST_TEST__ statement:
 
 `` 
   __BOOST_TEST__(c_a == c_b == 42); // does not compile
 ``]

[#what_is_a_sequence][h3 What is a sequence?]
A sequence is given by the iteration over a /forward iterable/ container. A forward iterable container is a container (C++11):

* that implements the member functions `size` and `begin`, as well as the fields `const_iterator` and `value_type`
* and for which `value_type` is not of type `char` or `wchar_t`

To that respect, C-arrays are *not* forward iterable containers:
[bt_example boost_test_macro_container_c_array..BOOST_TEST C-arrays]


The detection of the containers is delegated to the class [classref boost::unit_test::is_forward_iterable], which for C++11
detects the required member functions and fields. However for C++03, the types providing the sequences should be explicitly indicated
to the __UTF__ by a specialization of [classref boost::unit_test::is_forward_iterable]
[footnote Standard containers of the `STL` are recognised as collections.]. 

[endsect] [/ sequences]



[/ ################################################ ]
[section:strings String comparison]
In the general case, pointers are compared using their value. However when type of the the pointers are `char*` or `wchar_t*`, 
__BOOST_TEST__ promotes them as null terminated `char` arrays and string comparison is used instead. 

[bt_example boost_test_macro_string..BOOST_TEST string comparison]

[endsect] [/ string]

[section:options Options to `BOOST_TEST`]

The __BOOST_TEST__ assertion can be enriched with more control about the test or the diagnostic. In particular:

* an optional message, printed in case of failure and in place of the default message, can be added. 
* tags can be added in order to have a more detailed diagnostic. Currently only the bitwise comparison tag is available
* floating point tolerances can be controlled


[section:option_message Optional failure message]

When an assertion fails, a message is logged containing:

* the body of the statement that failed
* the name of the file and the line of the failed assertion
* the name of the test case containing this assertion

The purpose of all these information is to isolate as quickly as possible the test that failed from the others. The *feedback*
that the execution of the test case provides is an important cue, for the following reasons:

* within the scheme of a continuous build/test, the logs available from the server contain this information, which points to
  a particular statement in the code
* the *cost* for reproducing an error is induced by the following steps:
  
  * identify the test module that failed in case there are many
  * compile and run the test module to reproduce the error
  * identify the line of the code that failed, 
  * fix the test directly if all these informations are enough, or start a debug session 

We can see from the scheme above that reproduction of an error is /costly/, since usually one tends to reproduce the error,
which in turn induces at least the compilation of the test module. Also, a hidden cost is the lookup at the line of code
that contains the failing statement, which triggers a sequence of back and forth lookup between the log on one hand and the code
on the other hand.

The information extracted from the logs suggests the following fact: 

[tip Richness of the information contained in the logs is a key for the rapid understanding and the resolution of a failed statement]

While perfectly exact and precise, the file name, test case name, line number of a failed statement carries an information that 
is partial with regards to the meaning of the failed statement. 
Sometimes these information are not informative enough.

[bt_example boost_test_macro_message..BOOST_TEST optional failure message]


[endsect] [/ message]



[section:bitwise Bitwise comparison]

[caution this feature is not available for non C++11 compilers (the extended diagnostic is disabled).]

The tag [classref boost::test_tools::bitwise] can be provided to the __BOOST_TEST__ macro in order to have an extended bitwise comparison
of the operands. The predicate used for comparison ([funcref boost::test_tools::tt_detail::bitwise_compare `bitwise_compare`]) 
gives extended information on the locations where the two operands do not match. 

[bt_example boost_test_macro_bitwise..BOOST_TEST bitwise comparison]

[note the indices start at least significant bit.]


[endsect] [/ bit sequences]



[section:floating_point Floating point comparison]

[caution this feature is not available for non C++11 compilers (requires variadic macros and support of `auto` and `decltype`).
  Consider using [link boost_test.users_guide.tests_organization.decorators decorators] for setting the tolerance of the comparisons.]

__BOOST_TEST__ automatically detects expressions involving floating points and dispatch the expression to the 
appropriate comparison methods. More control can be provided over the tolerance with which the comparisons are made by
providing an optional [funcref boost::test_tools::tolerance] argument to __BOOST_TEST__. The tolerance might also be expressed
in /percentage/ using `operator%` of this tolerance object, as in the examples below:

[bt_example boost_test_macro_float..BOOST_TEST floating point comparison]

[note All floating point comparisons use Equ (2) on [link boost_test.users_guide.testing_tools.testing_floating_points this page].]

[caution A current caveat of the implementation requires the tolerance to be of the same type as of the first operand.]
[bt_example boost_test_macro_float2..BOOST_TEST tolerance type]

[endsect] [/ floating points]


[endsect] [/ options to boost_test]

[endsect] [/ boost_test_super_macro]

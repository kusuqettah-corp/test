[/
 / Copyright (c) 2015 Raffi Enficiaud
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:boost_test_super_macro `BOOST_TEST` or the Swiss Army knife]

Once a test case has been declared, the body of this test should be written. A test case is a 
sequence of operations in which *assertions* are inserted. Those assertions run /statements/ that verify the integrity 
of the pre and post conditions of the operations. There are three kind of assertions, having different meaning on the
consistency of the test case:

* requirements: this is the strongest level of the assertions. The test case execution stops if the statement in the assertion fails. This
  type of assertions should be used when the reminder of the test-case relies heavily on this requirement (example: an object 
  allocated on the heap is tested, but the factory returns `NULL`). 
* basic checks: this is the most commonly used assertion level. If the statements evaluates to `false`, the test case is 
  flagged as failed but its execution continues. 
* warnings: this is the lowest level of the assertions. The test case execution continues and a warning message is logged. 
  The warning does not change the success status of a test case.
  
These three levels of assertions are reported into the test log and test output, as described in details in the 
[link boost_test.users_guide.testing_tools.tools_assertion_severity_level severity levels] section. The granularity of the
report depends on the current [link boost_test.users_guide.runtime_config.rt_param_reference.param_log_level log level] and 
[link boost_test.users_guide.runtime_config.rt_param_reference.param_report_level report level].

A unique interface is given by the variants of the `BOOST_TEST` assertion:

* `BOOST_TEST_REQUIRE`
* `BOOST_TEST_CHECK` or just `BOOST_TEST`
* `BOOST_TEST_WARN`

As their name suggests, these assertions are, in order, for /requirement/, /checks/ and /warnings/.

[warning To get all the functionalities of `BOOST_TEST` family of assertions, a C++11 capable compiler is required, especially
 supporting the `auto` and `decltype` keywords and the variadic macros. The documentation focuses on these set of compilers. A 
 limited support is provided for C++03 compilers.]

[section:acceptable_statements Acceptable statements]

The __BOOST_TEST__ assertion uses some tricks with C++ operator overloading in order to perform its magic. This is why some expressions 
are in fact not possible, such as:

* statements containing ternary conditions: those statement should be surrounded by parenthesis as they cannot be overloaded
* statements containing comas: those statements will be intercepted by the preprocessor
* compound statements containing more than one sequence point

[bt_example boost_test_macro1..BOOST_TEST acceptable expressions]

[endsect] [/ acceptable expressions]

[section:collections Collection comparison]

The __BOOST_TEST__ assertion detects the /collections/ and provides additional diagnostics in case of failure. 
Collections are compared using a particular operator, applied on each element of both collections, in sequence.
The sequence of comparisons is provided by the iterators of the respective collections. 
In case of failure, the indices of the elements for which the comparison fails are returned.

In order for the collections to be comparable, they should have the same number of elements.

[caution the comparison is made over the elements returned by the collections iterators, using the operation appearing the in
 __BOOST_TEST__ statement (`==`, `<` ...). The type returned by the dereference of the iterator should support the selected operator.]

[bt_example boost_test_macro_collections..BOOST_TEST collection comparison support]

[h3 What is a collection?]
A collection is a sequence of elements (C++11):

* that implements the member functions `size` and `begin`, as well as the fields `const_iterator` and `value_type`
* and for which `value_type` is not of type `char` or `wchar_t`

To that respect, C-arrays are *not* collections.

The detection of the collection is delegated to the class [classref boost::unit_test::is_forward_iterable], which for C++11
detects the required member functions and fields. However for C++03, the types being collections should be explicitly indicated
to the __UTF__ by a specialization of [classref boost::unit_test::is_forward_iterable]. 

Standard containers of the `STL` are already indicated as collections. 

[endsect] [/ collections]

[section:strings String comparison]
In the general case, pointers are compared using their value. However when the pointers involved in the comparison
are `char *` or `wchar_t *`, __BOOST_TEST__ consider that the element pointed to are null terminated `char` arrays and
string comparison is used instead. 

[bt_example boost_test_macro_string..BOOST_TEST string comparison]

[endsect] [/ string]

[section:options Options to `BOOST_TEST`]

The __BOOST_TEST__ assertion can be enriched with more control about the test or the diagnostic. In particular:

* an optional message, printed in case of failure, can be added. 
* tags can be added in order to have a more detailed diagnostic. Currently only the bitwise comparison tag is available
* floating point tolerances can be controlled


[section:option_message Optional failure message]

When an assertion fails, a message is logged containing:

* the body of the statement that failed
* the name of the file and the line of the failed assertion
* the name of the test case containing this assertion

The purpose of all these information is to isolate as quickly as possible the test that failed from the others. The *feedback*
that the execution of the test case provides is an important cue, for the following reasons:

* within the scheme of a continuous build/test, the logs available from the server contain this information, which points to
  a particular statement in the code
* the *cost* for reproducing an error is induced by the following steps:
  
  * identify the test module that failed in case there are many
  * compile and run the test module to reproduce the error
  * identify the line of the code that failed, 
  * fix the test directly if all these informations are enough, or start a debug session 

We can see from the scheme above that reproduction of an error is /costly/, since usually one tends to reproduce the error,
which in turn induces at least the compilation of the test module. Also, a hidden cost is the lookup at the line of code
that contains the failing statement, which triggers a sequence of back and forth lookup between the log on one hand and the code
on the other hand.

The information extracted from the logs suggests the following fact: 

[tip Richness of the information contained in the logs is a key for the rapid understanding and the resolution of a failed statement]

While perfectly exact and precise, the file name, test case name, line number of a failed statement carries an information that 
is partial with regards to the meaning of the failed statement. 
Sometimes these information are not informative enough.

[bt_example boost_test_macro_message..BOOST_TEST optional failure message]


[endsect] [/ message]



[section:bitwise Bitwise comparison]

[caution this feature is not available for non C++11 compilers (the extended diagnostic is disabled).]

The tag [classref boost::test_tools::bitwise] can be provided to the __BOOST_TEST__ macro in order to have an extended bitwise comparison
of the operands. The predicate used for comparison ([funcref boost::test_tools::tt_detail::bitwise_compare `bitwise_compare`]) 
gives extended information on the locations where the two operands do not match. 

[bt_example boost_test_macro_bitwise..BOOST_TEST bitwise comparison]

[note the indices start at least significant bit.]


[endsect] [/ bit sequences]



[section:floating_point Comparing floating points]

[caution this feature is not available for non C++11 compilers (requires variadic macros and support of `auto` and `decltype`).
  Consider using [link boost_test.users_guide.tests_organization.decorators decorators] for setting the tolerance of the comparisons.]

__BOOST_TEST__ automatically detects expressions involving floating points and dispatch the expression to the 
appropriate comparison methods. 

[bt_example boost_test_macro_float..BOOST_TEST bitwise comparison]

[h4 Supported manipulators]

* [funcref boost::test_tools::tolerance] : indicates the tolerance, using Equ (2) indicated on 
  [link boost_test.users_guide.testing_tools.testing_floating_points this page].
  [bt_example boost_test_macro2..BOOST_TEST tolerance settings]
  [caution The tolerance should be of the same type as of the first operand]
* `% `[funcref boost::test_tools::tolerance]: indicates the tolerance in percentage


[endsect] [/ floating points]


[endsect] [/ options to boost_test]

[endsect] [/ boost_test_super_macro]

[/
 / Copyright (c) 2015 Raffi Enficiaud
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:boost_test_super_macro BOOST_TEST: universal and general purpose assertions]

Once a test case has been declared, the body of this test should be written. A test case is a 
sequence of operations in which *assertions* are inserted. Those assertions evaluate /statements/ that verify the integrity 
of the pre and post conditions of the operations. There are three kind of assertions, having different meaning on the
consistency of the test case:

* *requirements*: this is a strong condition for the operations following the assertion to be valid. 
  This type of assertions should be used when a pre-condition for the test is not met or when the test-case cannot continue.
  If such as assertion fails, the test case execution stops immediately, and the test-case is flagged as /failed/.
* *checks*: this is the most commonly used assertion level. If the statement evaluates to `false`, the test case is 
  flagged as failed but its execution continues. 
* *warnings*: this is an assertion providing information. The test case execution continues and a warning message is logged. 
  The warning does not change the success status of a test case.
  
These three levels of assertions are reported into the test log and output, as described in details in the 
[link boost_test.testing_tools.tools_assertion_severity_level severity levels] section. The granularity of the
report depends on the current [link boost_test.utf_reference.rt_param_reference.log_level log level] and 
[link boost_test.utf_reference.rt_param_reference.report_level report level].

A unique interface is given by three variants of the `BOOST_TEST` assertion:

* `BOOST_TEST_REQUIRE`
* `BOOST_TEST_CHECK` or just `BOOST_TEST`
* `BOOST_TEST_WARN`

As their name suggests these assertions are, in order, for /requirement/, /checks/ and /warnings/.

[warning To get all the functionalities of `BOOST_TEST` family of assertions, a C++11 capable compiler is required, especially
 supporting the `auto` and `decltype` keywords and the variadic macros. The documentation focuses on these set of compilers. A 
 limited support is provided for C++03 compilers.]


[/ ################################################ ]
[section:acceptable_statements Acceptable statements and reporting capability]
The general form of the `BOOST_TEST` macro is the following:

  BOOST_TEST(statement);
  BOOST_TEST(statement, optional_modifiers)

The __BOOST_TEST__ assertion uses operator overloading in order to provide an enhanced reporting capability; at the cost 
of narrowing the supported statements. The unsupported statements are:

* statements containing ternary conditions: those statement should be surrounded by parenthesis as they cannot be overloaded
* statements containing comas: those statements will be intercepted by the preprocessor
* compound statements containing any logical composition `||`, `&&`. Those are disabled intentionally and should be surrounded
  by parenthesis
  
    BOOST_TEST((true || false));
    
  The full details are given in [link boost_test_reports this section].

The `statement` might contain a full expression composed by several operations. `statement` should be castable to `bool`, 
as if it would appear as argument to an `if` statement.

[bt_example boost_test_macro1..BOOST_TEST acceptable expressions]

`BOOST_TEST` provides additional details in case of failure for binary overloadable operations in C++, 
except then ones mentioned above:
  
[table
  [[Class of operation][operators]]
  [[binary comparisons][`==`, `!=`, `<`, `>`, `<=`, `>=`]]
  [[arithmetic compositions][`+`, `-`, `*`, `/`, `%`]]
  [[bitwise compositions][`|`, `&`, `^`, `<<`, `>>`]]
  [[assignments][`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `^=`, `|=`]]
]  



[#boost_test_reports][h3 Reported information]
When an assertion fails, __BOOST_TEST__ reports details and values on the operands of `statement` that lead to the failure. 

[bt_example boost_test_macro3..BOOST_TEST reporting]

In the above example, the values of the operands are reported for inspection, which is more valuable as a copy
of the full statement. However, we can observe that they are not treated symmetrically:

* "`a - 1 < b`" reports `"13 - 1 >= 12" failed`
* "`b > a - 1`" reports `"12 <= 12" failed`

More details on how the __UTF__ parses the statement are given in [link boost_test.testing_tools.boost_test_super_macro.internal_details this] section.

[endsect] [/ acceptable expressions]


[/ ################################################ ]
[section:collections Sequences and collections comparison]

Instead of comparing one singular value against another, there is often the need to compare /sequences/ or /sets/ of values. 
Most of the time, the test for the full sequences is achieves through loops, or by using the native available operators 
for which no addtional diagnostic is provided.

__BOOST_TEST__ automatically detects *containers*, and let the user specify the comparison method:

* using the /native/ [footnote either defined by the container or by the user] operator, which is mentioned as the 
  [link boost_test_coll_default_comp /default behaviour/].
* using [link boost_test_coll_perelement element-wise] comparison
* using [link boost_test_coll_default_lex lexicographical] comparison

More details about what is considered to be a /containers/ is given [link what_is_a_sequence /here/].

[#boost_test_coll_default_comp][h3 Default comparison]
The default comparison dispatches to the existing overloaded operator. Given two containers `c_a` and `c_b`, 

``
BOOST_TEST(c_a op c_b)
``

is equivalent, in terms of test success, to 

``
auto result = c_a op c_b;
BOOST_TEST(result);
``

In the example below, `operator==` is not defined for `std::vector` of different types, and the program would fail to
compile if the corresponding lines were uncommented. `std::vector` uses lexicographical compare by default.

[bt_example boost_test_container_default..BOOST_TEST containers comparison default]

[#boost_test_coll_perelement][h3 Element-wise comparison]
By specifying the manipulator [classref boost::test_tools::per_element], the comparison of the elements of the containers
will be performed per-element, in the order given by the forward iterators of the containers. This is a comparison on
the /sequences/ of elements generated by the containers, for which the __UTF__ provides advanced diagnostic.

In more details, let `c_a = (a_1,... a_n)` and `c_b = (b_1,... b_n)` be two sequences of same length, but not necessarily of same type. 
Those sequences correspond to the content of the respective containers, in the order given by their iterator. Let 
`op` be one of the [link boost_test.testing_tools.boost_test_super_macro.acceptable_statements binary comparison operators].

``
BOOST_TEST(c_a op c_b, boost::test_tools::per_element() );
``

is equivalent to

``
if(c_a.size() == c_b.size()) 
{
  for(int i=0; i < c_a.size(); i++)
  {
    __BOOST_TEST_CONTEXT__("index" << i);
    BOOST_TEST(a_i op b_i);
  }
}
else
{
  BOOST_TEST(c_a.size() == c_b.size());
}
``

[warning this is fundamentally different from using the containers' default comparison operators (default behaviour).]
[warning this is not an order relationship on containers. As a side effect, it is possible to have eg.
 ``BOOST_TEST(c_a == c_b)`` and ``BOOST_TEST(c_a != c_b)`` failing at the same time]

Sequences are compared using the specified operator `op`, evaluated on the left and right elements of the respective sequences.
The order of elements is given by the iterators of the respective containers [footnote the containers should yield the same
sequences for a fixed set of elements they contain]. 
In case of failure, the indices of the elements failing `op` are returned.

[bt_example boost_test_sequence_per_element..BOOST_TEST sequence comparison]

[h4 Requirements]
For the sequences to be comparable element-wise, the following conditions should be met:

* the containers should yield the same number of elements
* `op` should be one of the comparison operator `==`, `!=`, `<`, `<=`, `>`, `>=`
* the `a_i op b_i` should be defined, where the type of `a_i` and `b_i` are the type returned by the dereference operator
  of the respective collections.

[caution the resulting type of "`c_a == c_b`" is an [classref boost::test_tools::assertion_result assertion_result]. It is not
 possible to compose more that one comparison on the BOOST_TEST statement:
 
 `` 
   BOOST_TEST(c_a == c_b == 42, boost::test_tools::per_element() ); // does not compile
 ``]
 
[#boost_test_coll_default_lex][h3 Lexicographic comparison]
By specifying the manipulator [classref boost::test_tools::lexicographic], the containers are compared using the /lexicographic/
order, for which the __UTF__ will provide additional information in case of failure.

``
BOOST_TEST(c_a op c_b, boost::test_tools::lexicographic() );
``
The comparison is performed in the order given by forward iterators of the containers.

[tip lexicographic comparison yields a total order on the containers: the statements `c_a < c_b` and 
 `c_b <= c_a` are mutually exclusive.]

[bt_example boost_test_container_lex..BOOST_TEST container comparison using lexicographical order]

[/ TODO ]
[/ [h4 Making lexicographic comparison the default] ]
[/ TODO ]

[h4 Requirements]

* the containers should be of the exact same type
* `op` should be one of the ordered comparison operator `<`, `<=`, `>`, `>=`


[#what_is_a_sequence][h3 What is a sequence?]
A sequence is given by the iteration over a /forward iterable/ container. A forward iterable container is a container (C++11):

* that implements the member functions `size` and `begin`, as well as the fields `const_iterator` and `value_type`
* and for which `value_type` is not of type `char` or `wchar_t`

To that respect, C-arrays are *not* forward iterable containers:
[bt_example boost_test_macro_container_c_array..BOOST_TEST C-arrays]


The detection of the containers is delegated to the class [classref boost::unit_test::is_forward_iterable], which for C++11
detects the required member functions and fields. However for C++03, the types providing the sequences should be explicitly indicated
to the __UTF__ by a specialization of [classref boost::unit_test::is_forward_iterable]
[footnote Standard containers of the `STL` are recognised as collections.]. 

[endsect] [/ sequences]



[/ ################################################ ]
[section:strings C-string comparison]
In the general case, pointers are compared using their value. However when type of the the pointers are `char*` or `wchar_t*`, 
__BOOST_TEST__ promotes them as null terminated `char` arrays and string comparison is used instead. 

[bt_example boost_test_string..BOOST_TEST string comparison]

[endsect] [/ string]


[/ ################################################ ]
[section:option_message Optional failure message]

When an assertion fails, a message is logged containing:

* the body of the statement that failed
* the name of the file and the line of the failed assertion
* the name of the test case containing this assertion

The purpose of all these information is to isolate as quickly as possible the test that failed from the others. The *feedback*
that the execution of the test case provides is an important cue, for the following reasons:

* within the scheme of a continuous build/test, the logs available from the server contain this information, which points to
  a particular statement in the code
* the *cost* for reproducing an error is induced by the following steps:
  
  * identify the test module that failed in case there are many
  * compile and run the test module to reproduce the error
  * identify the line of the code that failed, 
  * fix the test directly if all the information is enough, or start a debug session 

We can see from the scheme above that reproduction of an error is /costly/, since usually one tends to reproduce the error,
which in turn induces at least the compilation of the test module. Also, a hidden cost is the lookup at the line of code
that contains the failing statement, which triggers a sequence of back and forth lookup between the log on one hand and the code
on the other hand.

The information extracted from the logs suggests the following fact: 

[tip Richness of the information contained in the logs is a key for the rapid understanding and the resolution of a failed statement]

While perfectly exact and precise, the file name, test case name, line number of a failed statement carries an information that 
is partial with regards to the meaning of the failed statement. 
Sometimes these information are not informative enough.

[bt_example boost_test_message..BOOST_TEST optional failure message]


[endsect] [/ message]


[/ ################################################ ]
[section:bitwise Bitwise comparison]

[caution this feature is not available for non C++11 compilers.]

The manipulator [classref boost::test_tools::bitwise] can be provided to the __BOOST_TEST__ macro in order to have a bitwise comparison
of the operands. In that case, the __UTF__ indicates the bit indices where the two operands do not match. 

[bt_example boost_test_bitwise..BOOST_TEST bitwise comparison]

[note the indices start at least significant bit.]


[endsect] [/ bit sequences]


[/ ################################################ ]
[section:floating_point Floating point comparison]

Unless you specify otherwise, when two floating-point types are compared inside assertion  __BOOST_TEST__,
the resulting check is not 'direct' (as implemented by operators `==` and `<` for these types),
but uses [link boost_test.testing_tools.testing_floating_points comparison with tolerance] instead.
The tolerance threshold used is the one defined per test case. See 
the decorator __decorator_tolerance__ for setting test-case-local tolerance.

If there is a need for customizing floating point comparison tolerance per single assertion, you can do it by providing a 
second argument to __BOOST_TEST__. Such second argument is called a /manipulator/.

[caution The support for manipulators requires that your compiler supports variadic macros, `auto` for type deduction
 and `decltype`. These are C++11 features, but are also available on some pre-C++11 compilers.]
 
Manipulator [funcref boost::test_tools::tolerance] can be used in three ways. They are illustrated in the following example:

[bt_example test_float_01..manipulator tolerance]

In the above example, the first assertion is using the default tolerance, which makes the comparison fail. In the second assertion 
a tolerance for type `double` of value 0.002 is specified. The numbers are compared using the algorithm Equ (4) on 
[link boost_test.testing_tools.testing_floating_points this page]; the algorithm treats the two values as 
sufficiently small to pass the test. In the third assertion we use the percent tolerance; it is equivalent to the second 
assertion. The fourth assertion is another syntax for representing the percent tolerance: it is equivalent to the third assertion. 

[note All floating point comparisons use Equ (4) on [link boost_test.testing_tools.testing_floating_points this page].]

Manipulator `tolerance` specifies the tolerance only for a single floating-point type. This type is deduced from form 
the numeric value passed along the manipulator:

[table
[[manipulator expression][semantics]]
[[`tolerance(0.5)`][relative tolerance for type `double` changed to 0.5]]
[[`tolerance(float(0.5))`][relative tolerance for type `float` changed to 0.5]]
[[`tolerance(0.5f)`][relative tolerance for type `float` changed to 0.5]]
[[`5.0 % tolerance()`][relative tolerance for type `double` changed to 0.05 (5.0 * 0.01)]]
[[`5.0f % tolerance()`][relative tolerance for type `float` changed to 0.05]]
]

In case different types of floating point numbers are being compared in one assertion, the types are promoted according 
to C++ type promotion and conversion rules, and the resulting type is the one whose tolerance is considered. For instance, 
when setting a tolerance for mixed `float`-to-`double` comparison, the tolerance for type `double` needs to be set. This 
is illustrated by the following example.

[bt_example test_float_02..tolerance for mixed floating-point types]

The specified tolerance only applies when comparing values that are recognized as floating point types in the expression 
tree contained in the assertion body. It does not apply to user-defined types even when they use floating-point comparison inside:

[bt_example test_float_03..tolerance for non-fp types]

The __UTF__ recognizes that a given type `T` is a floating-point type using the expression 
[classref boost::math::fpc::tolerance_based]`<T>::value`. This meta-function already returns true for built-in 
floating-point types as well as for user defined-types that specialize `std::numeric_limits`. You can also specialize 
[classref boost::math::fpc::tolerance_based] for your type directly:

[bt_example test_float_04..adapting user-defined types for tolerance-based comparison]


[endsect] [/ floating points]

[/ ################################################ ]
[section:internal_details Technical details]
Let's consider the following example:

[bt_example boost_test_macro3..BOOST_TEST reporting]

It was already mentioned that the reporting is not symmetrical (see [link boost_test_reports here]). 
An expression is constructed from the `statement` appearing in the `BOOST_TEST` macro. This expression allows evaluation and reporting such
as `"13 - 1 >= 12" failed` along with a copy of the `statement`, which contains more details than `"a - 1 < b" failed`. 
In details, what happens is the following:

# a special object, the `seed` of the expression, is composed from the left side of `statement`. 
  This initial composition has highest precedence over the supported operations. The expression below:

    a op1 b op2 c op3 d
  
  is actually seen as
  
    ( seed a ) op1 b op2 c op3 d

# The "`seed a`" returns an `expression` object that keep tracks of the type of `a`. This expression 
  has overloads for left-to-right associativity, and the 
  operations `op1`, `op2` ... are /chained/ to the right of this expression object:
  
    a op1 b
    
  yields to the pseudo-code
  
    expression1 = create-expression(a)
    expression2 = create-expression(expression1, op1, b)
    
  `expression1` and `expression2` keep track of their left and right operands, and the operation on those operands. The
  expressions keep also track of the result type of the associated sub-expression. In the above example, `expression1` and `expression2` 
  have result type `decltype(a)` and `decltype(a op1 b)` respectively. The result type allows for chaining 
  sub-expressions.

# The C++ operators precedence rules apply in any case. What is seen by the expression is what is reachable with left-to-right
  composition. Any other operation that happens before it reaches the expression's right operand is not parsed as a sub-expression
  and is seen as a single operand: the right operand is not developed further by the framework. 
  Let's suppose `op2` below has higher precedence than `op1`, then 

    a op1 b op2 c
  
  is equivalent to:
  
    create-expression(create-expression(a), op1, (b op2 c))

  In the above statement, the final expression can only see the result of `(b op2 c)` to its right, for which no further detail 
  can be provided in the logs. This is also the case for /right-to-left/ associative operators, such as `!`, `~`, `-` (unary negation) 
  etc.
  
  [caution Since the `expression` object is composed from left-to-right, it actually observes a chain of operations and
    not the full expression tree.]

# Once the full expression chain is built, it is evaluated as a chain of sub-expressions from left-to-right, exactly as the 
  composition rule above. The evaluated elements are the ones of the expression itself. The expression
  
    a op1 b
    
  yields to the following evaluation chain:
  
    expression2.result = expression1.result op1 b
    expression1.result = a
    
  The final expression of the statement is casted to a boolean, which is in turn evaluated by the __UTF__.


The example below illustrates the construction of the left-to-right /chained/ expression.
 
[bt_example boost_test_macro2..BOOST_TEST compound statements]
[endsect]

[endsect] [/ boost_test_super_macro]

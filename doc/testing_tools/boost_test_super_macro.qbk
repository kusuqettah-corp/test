[/
 / Copyright (c) 2015 Raffi Enficiaud
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:boost_test_super_macro `BOOST_TEST` or the Swiss Army knife]

Once a test case has been declared, the body of this test should be written. A test case is a 
sequence of operations in which *assertions* are inserted. Those assertions evaluate /statements/ that verify the integrity 
of the pre and post conditions of the operations. There are three kind of assertions, having different meaning on the
consistency of the test case:

* *requirements*: this is a strong condition for the operations following the assertion to be valid. 
  This type of assertions should be used when a pre-condition for the test is not met or when the test-case cannot continue.
  If such as assertion fails, the test case execution stops immediately, and the test-case is flagged as /failed/.
* *checks*: this is the most commonly used assertion level. If the statement evaluates to `false`, the test case is 
  flagged as failed but its execution continues. 
* *warnings*: this is the lowest level of the assertions. The test case execution continues and a warning message is logged. 
  The warning does not change the success status of a test case.
  
These three levels of assertions are reported into the test log and output, as described in details in the 
[link boost_test.users_guide.testing_tools.tools_assertion_severity_level severity levels] section. The granularity of the
report depends on the current [link boost_test.users_guide.runtime_config.rt_param_reference.param_log_level log level] and 
[link boost_test.users_guide.runtime_config.rt_param_reference.param_report_level report level].

A unique interface is given by three variants of the `BOOST_TEST` assertion:

* `BOOST_TEST_REQUIRE`
* `BOOST_TEST_CHECK` or just `BOOST_TEST`
* `BOOST_TEST_WARN`

As their name suggests these assertions are, in order, for /requirement/, /checks/ and /warnings/.

[warning To get all the functionalities of `BOOST_TEST` family of assertions, a C++11 capable compiler is required, especially
 supporting the `auto` and `decltype` keywords and the variadic macros. The documentation focuses on these set of compilers. A 
 limited support is provided for C++03 compilers.]

[section:acceptable_statements Acceptable statements]

The __BOOST_TEST__ assertion uses some tricks with C++ operator overloading in order to perform its magic. This is why some expressions 
are in fact not possible, such as:

* statements containing ternary conditions: those statement should be surrounded by parenthesis as they cannot be overloaded
* statements containing comas: those statements will be intercepted by the preprocessor
* compound statements containing more than one sequence point

[bt_example boost_test_macro1..BOOST_TEST acceptable expressions]

[endsect] [/ acceptable expressions]

[section:collections Collection comparison]

__BOOST_TEST__ automatically detects [link what_is_a_collection /collections/] of elements and provides additional diagnostics in case of failure. 
Collections are compared using a specified operator, applied /in sequence/ on each element of both collections.
The sequence of comparisons is provided by the iterators of the respective collections. 
In case of failure, the indices of the elements for which the comparison fails are returned.

In order for the collections to be comparable, they should have the same number of elements.

[caution the comparison is made over the elements returned by the collections iterators, using the operation appearing the in
 __BOOST_TEST__ statement (`==`, `<` ...). The type returned by the dereference of the iterator should support the selected operator.]

[bt_example boost_test_macro_collections..BOOST_TEST collection comparison support]

[#what_is_a_collection][h3 What is a collection?]
A collection is a sequence of elements (C++11):

* that implements the member functions `size` and `begin`, as well as the fields `const_iterator` and `value_type`
* and for which `value_type` is not of type `char` or `wchar_t`

To that respect, C-arrays are *not* collections.

The detection of the collection is delegated to the class [classref boost::unit_test::is_forward_iterable], which for C++11
detects the required member functions and fields. However for C++03, the types being collections should be explicitly indicated
to the __UTF__ by a specialization of [classref boost::unit_test::is_forward_iterable]. 

Standard containers of the `STL` are recognised as collections. 

[endsect] [/ collections]

[section:strings String comparison]
In the general case, pointers are compared using their value. However when type of the the pointers are `char*` or `wchar_t*`, 
__BOOST_TEST__ promotes them as null terminated `char` arrays and string comparison is used instead. 

[bt_example boost_test_macro_string..BOOST_TEST string comparison]

[endsect] [/ string]

[section:options Options to `BOOST_TEST`]

The __BOOST_TEST__ assertion can be enriched with more control about the test or the diagnostic. In particular:

* an optional message, printed in case of failure and in place of the default message, can be added. 
* tags can be added in order to have a more detailed diagnostic. Currently only the bitwise comparison tag is available
* floating point tolerances can be controlled


[section:option_message Optional failure message]

When an assertion fails, a message is logged containing:

* the body of the statement that failed
* the name of the file and the line of the failed assertion
* the name of the test case containing this assertion

The purpose of all these information is to isolate as quickly as possible the test that failed from the others. The *feedback*
that the execution of the test case provides is an important cue, for the following reasons:

* within the scheme of a continuous build/test, the logs available from the server contain this information, which points to
  a particular statement in the code
* the *cost* for reproducing an error is induced by the following steps:
  
  * identify the test module that failed in case there are many
  * compile and run the test module to reproduce the error
  * identify the line of the code that failed, 
  * fix the test directly if all these informations are enough, or start a debug session 

We can see from the scheme above that reproduction of an error is /costly/, since usually one tends to reproduce the error,
which in turn induces at least the compilation of the test module. Also, a hidden cost is the lookup at the line of code
that contains the failing statement, which triggers a sequence of back and forth lookup between the log on one hand and the code
on the other hand.

The information extracted from the logs suggests the following fact: 

[tip Richness of the information contained in the logs is a key for the rapid understanding and the resolution of a failed statement]

While perfectly exact and precise, the file name, test case name, line number of a failed statement carries an information that 
is partial with regards to the meaning of the failed statement. 
Sometimes these information are not informative enough.

[bt_example boost_test_macro_message..BOOST_TEST optional failure message]


[endsect] [/ message]



[section:bitwise Bitwise comparison]

[caution this feature is not available for non C++11 compilers (the extended diagnostic is disabled).]

The tag [classref boost::test_tools::bitwise] can be provided to the __BOOST_TEST__ macro in order to have an extended bitwise comparison
of the operands. The predicate used for comparison ([funcref boost::test_tools::tt_detail::bitwise_compare `bitwise_compare`]) 
gives extended information on the locations where the two operands do not match. 

[bt_example boost_test_macro_bitwise..BOOST_TEST bitwise comparison]

[note the indices start at least significant bit.]


[endsect] [/ bit sequences]



[section:floating_point Floating point comparison]

[caution this feature is not available for non C++11 compilers (requires variadic macros and support of `auto` and `decltype`).
  Consider using [link boost_test.users_guide.tests_organization.decorators decorators] for setting the tolerance of the comparisons.]

__BOOST_TEST__ automatically detects expressions involving floating points and dispatch the expression to the 
appropriate comparison methods. More control can be provided over the tolerance with which the comparisons are made by
providing an optional [funcref boost::test_tools::tolerance] argument to __BOOST_TEST__. The tolerance might also be expressed
in /percentage/ using `operator%` of this tolerance object, as in the examples below:

[bt_example boost_test_macro_float..BOOST_TEST bitwise comparison]

[note All floating point comparisons use Equ (2) on [link boost_test.users_guide.testing_tools.testing_floating_points this page].]

[caution The tolerance should be of the same type as of the first operand
 [bt_example boost_test_macro2..BOOST_TEST tolerance settings]
]

[endsect] [/ floating points]


[endsect] [/ options to boost_test]

[endsect] [/ boost_test_super_macro]

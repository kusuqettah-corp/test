[/
 / Copyright (c) 2015 Raffi Enficiaud
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:boost_test_super_macro BOOST_TEST or the Swiss Army knife]

Once a test case has been declared, the body of this test should be written. A test case is a 
sequence of operations in which *assertions* are inserted. Those assertions evaluate /statements/ that verify the integrity 
of the pre and post conditions of the operations. There are three kind of assertions, having different meaning on the
consistency of the test case:

* *requirements*: this is a strong condition for the operations following the assertion to be valid. 
  This type of assertions should be used when a pre-condition for the test is not met or when the test-case cannot continue.
  If such as assertion fails, the test case execution stops immediately, and the test-case is flagged as /failed/.
* *checks*: this is the most commonly used assertion level. If the statement evaluates to `false`, the test case is 
  flagged as failed but its execution continues. 
* *warnings*: this is an assertion providing information. The test case execution continues and a warning message is logged. 
  The warning does not change the success status of a test case.
  
These three levels of assertions are reported into the test log and output, as described in details in the 
[link boost_test.users_guide.testing_tools.tools_assertion_severity_level severity levels] section. The granularity of the
report depends on the current [link boost_test.users_guide.runtime_config.rt_param_reference.param_log_level log level] and 
[link boost_test.users_guide.runtime_config.rt_param_reference.param_report_level report level].

A unique interface is given by three variants of the `BOOST_TEST` assertion:

* `BOOST_TEST_REQUIRE`
* `BOOST_TEST_CHECK` or just `BOOST_TEST`
* `BOOST_TEST_WARN`

As their name suggests these assertions are, in order, for /requirement/, /checks/ and /warnings/.

[warning To get all the functionalities of `BOOST_TEST` family of assertions, a C++11 capable compiler is required, especially
 supporting the `auto` and `decltype` keywords and the variadic macros. The documentation focuses on these set of compilers. A 
 limited support is provided for C++03 compilers.]


[/ ################################################ ]
[section:acceptable_statements Acceptable statements and reporting capability]
The general form of the `BOOST_TEST` macro is the following:

  BOOST_TEST(statement);
  BOOST_TEST(statement, optional_modifiers)

The __BOOST_TEST__ assertion uses operator overloading in order to provide an enhanced reporting capability; at the cost 
of narrowing the supported statements. The unsupported statements are:

* statements containing ternary conditions: those statement should be surrounded by parenthesis as they cannot be overloaded
* statements containing comas: those statements will be intercepted by the preprocessor
* compound statements containing any logical composition `||`, `&&`. Those are disabled intentionally and should be surrounded
  by parenthesis
  
    BOOST_TEST((true || false));
    
  The full details are given in [link boost_test_reports this section].

The `statement` might contain a full expression composed by several operations. `statement` should be castable to `bool`, 
as if it would appear as argument to an `if` statement.

[bt_example boost_test_macro1..BOOST_TEST acceptable expressions]

`BOOST_TEST` provides additional details in case of failure for binary overloadable operations in C++, 
except then ones mentioned above:
  
[table
  [[Class of operation][operators]]
  [[binary comparisons][`==`, `!=`, `<`, `>`, `<=`, `>=`]]
  [[arithmetic compositions][`+`, `-`, `*`, `/`, `%`]]
  [[bitwise compositions][`|`, `&`, `^`, `<<`, `>>`]]
  [[assignments][`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `^=`, `|=`]]
]  



[#boost_test_reports][h3 Reported information]
When an assertion fails, __BOOST_TEST__ reports details and values on the operands of `statement` that lead to the failure. 

[bt_example boost_test_macro3..BOOST_TEST reporting]

In the above example, the values of the operands are reported for inspection, which is more valuable as a copy
of the full statement. However, we can observe that they are not treated symmetrically:

* "`a - 1 < b`" reports "`13 - 1 >= 12`"
* "`b > a - 1`" reports "`12 <= 12`"

An expression is constructed from the `statement` appearing in the `BOOST_TEST` macro. This expression allows report such
as "`13 - 1 >= 12`". In details, what happens is the following:

# a special object, the `seed` of the expression, is composed 
  from the left side of `statement`. This initial composition has highest precedence over the allowed operations. The expression below:

    a op1 b op2 c op3 d
  
  is actually seen as
  
    ( seed a ) op1 b op2 c op3 d

# The "`seed a`" evaluates to an `expression`. This expression has overloads for left to right associativity, and the 
  operations `op1`, `op2` ... are /chained/ to the right of this expression object:
  
    a op1 b
    
  yields to the pseudo-code
  
    expression1 = seed a
    expression2 = expression1->operator op1(b)

# The C++ operators precedence rules apply in any case. What is seen by the expression is what is reachable from left to right
  composition. Any other operation that happens before it reaches the expression right operand is seen as a single operand. 
  Let's suppose `op2` below has higher precedence than `op1`, then 

    a op1 b op2 c
  
  is equivalent to:
  
    ( seed a ) op1 (b op2 c)

  such that the final expression can only see `(b op2 c)` to its right, for which no further detail can be provided in 
  case of failure. This is also the case for right-to-left associative operators, such as `!`, `~`, etc.

[tip Since the `expression` object is composed from left-to-right, it actually observes a chain of operations and
 not the full expression tree.]

The example below illustrates the construction of the left-to-right /chained/ expression.
 
[bt_example boost_test_macro2..BOOST_TEST compound statements]

[endsect] [/ acceptable expressions]


[/ ################################################ ]
[section:collections Sequences and collections comparison]

Instead of comparing one singular value against another, there is often the need to compare /sequences/ or /sets/ of values. 
Most of the time, the test for the full sequences is achieves through loops.

__BOOST_TEST__ automatically detects [link what_is_a_sequence /containers/] that provide sequences of elements, and allows
to specify an additional comparison method:

* using the /available/ [footnote either defined by the container or by the user] operator, which is mentioned as the 
  [link boost_test_coll_default_comp /default behaviour/].
* using [link boost_test_coll_perelement element-wise] comparison
* using [link boost_test_coll_default_lex lexicographical] comparison

[#boost_test_coll_default_comp][h3 Default behaviour]
The default behaviour dispatches to the existing operator. Given two containers `c_a` and `c_b`, 

``
BOOST_TEST(c_a op c_b)
``

is equivalent, in terms of test success, to 

``
auto result = c_a op c_b;
BOOST_TEST(result);
``

[#boost_test_coll_perelement][h3 Element-wise comparison]
By specifying the tag [classref boost::test_tools::per_element], the comparison of the elements of the containers
will be performed per-element, in the sequence given by the forward iterators of the containers.

In more details, let's `c_a = (a_1,... a_n)` and `c_b = (b_1,... b_n)` be two containers of same size, but not necessarily of same type, and 
let `op` be one of the [link boost_test.users_guide.testing_tools.boost_test_super_macro.acceptable_statements binary comparison operators].

``
__BOOST_TEST__(c_a op c_b, [classref boost::test_tools::per_element]() );
``

is equivalent to

``
bool result(c_a.size() == c_b.size());
if(result) 
{
  for(int i=0; i < c_a.size(); i++)
  {
    __BOOST_TEST_CONTEXT__("index" << i);
    result &= a_i op b_i;
  }
}
BOOST_TEST(result);
``

[warning this is fundamentally different from using the containers' default comparison operators (default behaviour).]

Sequences are compared using the specified operator `op`, evaluated on the left and right elements of the respective sequences,
/in order/.
The order of elements is given by the iterators of the respective containers [footnote the containers should yield the same
sequences for a fixed set of elements they contain]. 
In case of failure, the indices of the elements failing `op` are returned.

[bt_example boost_test_macro_sequence..BOOST_TEST sequence comparison]

[h3 Requirements]
For the sequences to be comparable element-wise, the following conditions should be met:

* the containers should yield the same number of elements
* `op` should be one of the comparison operator `==`, `!=`, `<`, `<=`, `>`, `>=`
* the `a_i op b_i` should be defined, where the type of `a_i` and `b_i` are the type returned by the dereference operator
  of the respective collections:  
  [bt_example boost_test_macro_container_value_type..BOOST_TEST comparison defined on elements]

[caution the resulting type of "`c_a == c_b`" is an [classref boost::test_tools::assertion_result assertion_result]. It is not
 possible to compose more that one comparison on the __BOOST_TEST__ statement:
 
 `` 
   __BOOST_TEST__(c_a == c_b == 42, boost::test_tools::per_element() ); // does not compile
 ``]
 
[#boost_test_coll_default_lex][h3 Lexicographical comparison]

[#what_is_a_sequence][h3 What is a sequence?]
A sequence is given by the iteration over a /forward iterable/ container. A forward iterable container is a container (C++11):

* that implements the member functions `size` and `begin`, as well as the fields `const_iterator` and `value_type`
* and for which `value_type` is not of type `char` or `wchar_t`

To that respect, C-arrays are *not* forward iterable containers:
[bt_example boost_test_macro_container_c_array..BOOST_TEST C-arrays]


The detection of the containers is delegated to the class [classref boost::unit_test::is_forward_iterable], which for C++11
detects the required member functions and fields. However for C++03, the types providing the sequences should be explicitly indicated
to the __UTF__ by a specialization of [classref boost::unit_test::is_forward_iterable]
[footnote Standard containers of the `STL` are recognised as collections.]. 

[endsect] [/ sequences]



[/ ################################################ ]
[section:strings String comparison]
In the general case, pointers are compared using their value. However when type of the the pointers are `char*` or `wchar_t*`, 
__BOOST_TEST__ promotes them as null terminated `char` arrays and string comparison is used instead. 

[bt_example boost_test_macro_string..BOOST_TEST string comparison]

[endsect] [/ string]


[/ ################################################ ]
[section:option_message Optional failure message]

When an assertion fails, a message is logged containing:

* the body of the statement that failed
* the name of the file and the line of the failed assertion
* the name of the test case containing this assertion

The purpose of all these information is to isolate as quickly as possible the test that failed from the others. The *feedback*
that the execution of the test case provides is an important cue, for the following reasons:

* within the scheme of a continuous build/test, the logs available from the server contain this information, which points to
  a particular statement in the code
* the *cost* for reproducing an error is induced by the following steps:
  
  * identify the test module that failed in case there are many
  * compile and run the test module to reproduce the error
  * identify the line of the code that failed, 
  * fix the test directly if all these informations are enough, or start a debug session 

We can see from the scheme above that reproduction of an error is /costly/, since usually one tends to reproduce the error,
which in turn induces at least the compilation of the test module. Also, a hidden cost is the lookup at the line of code
that contains the failing statement, which triggers a sequence of back and forth lookup between the log on one hand and the code
on the other hand.

The information extracted from the logs suggests the following fact: 

[tip Richness of the information contained in the logs is a key for the rapid understanding and the resolution of a failed statement]

While perfectly exact and precise, the file name, test case name, line number of a failed statement carries an information that 
is partial with regards to the meaning of the failed statement. 
Sometimes these information are not informative enough.

[bt_example boost_test_macro_message..BOOST_TEST optional failure message]


[endsect] [/ message]


[/ ################################################ ]
[section:bitwise Bitwise comparison]

[caution this feature is not available for non C++11 compilers (the extended diagnostic is disabled).]

The tag [classref boost::test_tools::bitwise] can be provided to the __BOOST_TEST__ macro in order to have an extended bitwise comparison
of the operands. The predicate used for comparison ([funcref boost::test_tools::tt_detail::bitwise_compare `bitwise_compare`]) 
gives extended information on the locations where the two operands do not match. 

[bt_example boost_test_macro_bitwise..BOOST_TEST bitwise comparison]

[note the indices start at least significant bit.]


[endsect] [/ bit sequences]


[/ ################################################ ]
[section:floating_point Floating point comparison]

Unless you specify otherwise, when two floating-point types are compared inside assertion  __BOOST_TEST__,
the resulting check is not 'direct' (as implemented by operators `==` and `<` for these types),
but uses [link boost_test.users_guide.testing_tools.testing_floating_points comparison with tolerance] instead.
The tolerance threshold used is the one defined per test case. See 
[link boost_test.users_guide.tests_organization.decorators.decorator_tolerance here] for setting test-case-local tolerance.

If there is a need for customizing floating point comparison tolerance per single assertion, you can do it by providing a 
second argument to __BOOST_TEST__. Such second argument is called a /manipulator/.

[caution The support for manipulators requires that your compiler supports variadic macros, `auto` for type deduction
 and `decltype`. These are C++11 features, but are also available on some pre-C++11 compilers.]
 
Manipulator [funcref boost::test_tools::tolerance] can be used in three ways. They are illustrated in the following example:

[bt_example test_float_01..manipulator tolerance]

In the above example, the first assertion is using the default tolerance, which makes the comparison fail. In the second assertion 
a tolerance for type `double` of value 0.002 is specified. The numbers are compared using the algorithm Equ (4) on 
[link boost_test.users_guide.testing_tools.testing_floating_points this page]; the algorithm treats the two values as 
sufficiently small to pass the test. In the third assertion we use the percent tolerance; it is equivalent to the second 
assertion. The fourth assertion is another syntax for representing the percent tolerance: it is equivalent to the third assertion. 

[note All floating point comparisons use Equ (4) on [link boost_test.users_guide.testing_tools.testing_floating_points this page].]

Manipulator `tolerance` specifies the tolerance only for a single floating-point type. This type is deduced from form 
the numeric value passed along the manipulator:

[table
[[manipulator expression][semantics]]
[[`tolerance(0.5)`][relative tolerance for type `double` changed to 0.5]]
[[`tolerance(float(0.5))`][relative tolerance for type `float` changed to 0.5]]
[[`tolerance(0.5f)`][relative tolerance for type `float` changed to 0.5]]
[[`5.0 % tolerance()`][relative tolerance for type `double` changed to 0.05 (5.0 * 0.01)]]
[[`5.0f % tolerance()`][relative tolerance for type `float` changed to 0.05]]
]

In case different types of floating point numbers are being compared in one assertion, the types are promoted according 
to C++ type promotion and conversion rules, and the resulting type is the one whose tolerance is considered. For instance, 
when setting a tolerance for mixed `float`-to-`double` comparison, the tolerance for type `double` needs to be set. This 
is illustrated by the following example.

[bt_example test_float_02..tolerance for mixed floating-point types]

The specified tolerance only applies when comparing values that are recognized as floating point types in the expression 
tree contained in the assertion body. It does not apply to user-defined types even when they use floating-point comparison inside:

[bt_example test_float_03..tolerance for non-fp types]

The __UTF__ recognizes that a given type `T` is a floating-point type using the expression 
[classref boost::math::fpc::tolerance_based]`<T>::value`. This meta-function already returns true for built-in 
floating-point types as well as for user defined-types that specialize `std::numeric_limits`. You can also specialize 
[classref boost::math::fpc::tolerance_based] for your type directly:

[bt_example test_float_04..adapting user-defined types for tolerance-based comparison]


[endsect] [/ floating points]

[endsect] [/ boost_test_super_macro]

[section:test_cases Test cases]
A test case has to be constructed based on some kind of
function and registered in a test tree, so that the test runner knows how to invoke it. There are different
possible designs for the test case construction problem: inheritance from the predefined base class, specifically
named member function and so on. The __UTF__ opted to avoid classed altogether and to use the 
least intrusive ['generic callback] approach.
The facility the __UTF__ provides, requires specific function signature and allows
adopting any function or function object that matches the signature as a test case. The signatures the __UTF__
supports are:

* Nullary function
* Unary function
* Nullary function template

Generic test case construction design used by the __UTF__ causes the test case implementation (test function body)
and test case creation/registration points to be remote. As a result you may forget to register the test case
and it's never going to be executed, even though it's present in test file. To alleviate this issue
the __UTF__ presents facilities for automated (in place) test case creation and registration in the test tree. These
facilities sacrifice some generality and work for selected test function signatures only. But the result is that
library users are relieved from the necessity to manually register test cases. These facilities are the most
user-friendly and are recommended to be used whenever possible. In addition they support automated registration
of test suites, thus allowing whole test tree to be created without any use of manual registration.

The single test module may mix both automated and manual test case
registration. In other words, within the same test module you can have both test cases implemented remotely and
registered manually in the test module initialization function and test cases that are registered automatically at
implementation point.


[/ ############################################# ]
[include nullary_tests.qbk]

 
[#ref_BOOST_PARAM_TEST_CASE][section Unary function based test case]

Some tests are required to be repeated for a series of different input parameters. One way to achieve this is
manually register a test case for each parameter as in example above. You can also invoke a test function with
all parameters manually from within your test case, like this:

``
void single_test( int i )
{
  BOOST_CHECK( /* test assertion */ );
}

void combined_test()
{
  int params[] = { 1, 2, 3, 4, 5 };
  std::for_each( params, params+5, &single_test );
}
``

The __UTF__ presents a better solution for this problem: the unary function based test case, also referred as
['parameterized test case]. The unary test function can be a free function, unary functor (for example created
with `boost::bind`) or unary method of a class with bound test class instance). The test function is converted
into test case using the macro __BOOST_PARAM_TEST_CASE__. The macro expects a collection of parameters (passed as
two input iterators) and an unary test function:

``
  BOOST_PARAM_TEST_CASE(test_function, params_begin, params_end);
``
 

__BOOST_PARAM_TEST_CASE__ creates an instance of the test case generator. When passed to the method `test_suite::add`,
the generator produces a separate sub test case for each parameter in the parameters collection and registers
it immediately in a test suite. Each test case is based on a test function with the parameter bound by value,
even if the test function expects a parameter by reference. The fact that parameter value is stored along with
bound test function releases you from necessity to manage parameters lifetime. For example, they can be defined
in the test module initialization function scope.

All sub test case names are deduced from the macro argument test_function. If you prefer to assign different
names, you have to use the underlying make_test_case interface instead. Both test cases creation and
registration are performed in the test module initialization function.

The parameterized test case facility is preferable to the approach in the example above, since execution of
each sub test case is guarded and counted independently. It produces a better test log/results report (in
example above in case of failure you can't say which parameter is at fault) and allows you to test against
all parameters even if one of them causes termination a particular sub test case.

In comparison with a manual test case registration for each parameter approach the parameterized test case
facility is more concise and easily extendible.

In following simple example the same test, implemented in `free_test_function`, is
performed for 5 different parameters. The parameters are defined in the test module initialization function
scope. The master test suite contains 5 independent test cases.


[import ../examples/example07.cpp]
[import ../examples/example07.output]
[table:id_example07 Unary free function based test case
  [
    [Code]
    [Output]
  ]
  [
    [[example07]]
    [[example07o]]
  ]
]



Next example is similar, but instead of a free function it uses a method of a class. Even though parameters are
passed into test method by reference you can still define them in the test module initialization  function scope.
This example employs the alternative test module initialization function specification.

[import ../examples/example08.cpp]
[import ../examples/example08.output]
[table:id_example08 Unary class method based test case
  [
    [Code]
    [Output]
  ]
  [
    [[example08]]
    [[example08o]]
  ]
]

[endsect] [/test case with arity]



[section:test_organization_templates Template test cases]

To test a template based component it's frequently necessary to perform the same set of checks for a
component instantiated with different template parameters. The __UTF__ provides the ability to create a series of
test cases based on a list of desired types and function similar to nullary function template. This facility is
called test case template. Here are the two construction interfaces:

* Test case template with automated registration
* Manually registered test case template

[#ref_BOOST_AUTO_TEST_CASE_TEMPLATE][h4 Test case template with automated registration]

To create a test case template registered in place of implementation, employ the macro
__BOOST_AUTO_TEST_CASE_TEMPLATE__. This facility is also called ['auto test case template].

``
BOOST_AUTO_TEST_CASE_TEMPLATE(test_case_name, formal_type_parameter_name, collection_of_types);
``

The macro __BOOST_AUTO_TEST_CASE_TEMPLATE__ requires three arguments:

# `test_case_name` The test case template name: unique test cases template identifier
# `formal_type_parameter_name` The name of a formal template parameter:
         name of the type the test case template is instantiated with
# The collection of types to instantiate test case template with: arbitrary MPL sequence

[import ../examples/example10.cpp]
[import ../examples/example10.output]
[table:id_example10 Test case template with automated registration
  [
    [Code]
    [Output]
  ]
  [
    [[example10]]
    [[example10o]]
  ]
]

[#ref_BOOST_TEST_CASE_TEMPLATE][h4 Test case template with manual registration]
One way to perform the same set of checks for a component instantiated with different template parameters is
illustrated in the following example:

[/snippet2 deleted and copied below]
``
template <typename T>
void single_test()
{
  BOOST_CHECK( /* test assertion */ );
}

void combined_test()
{
  single_test<int>();
  single_test<float>();
  single_test<unsigned char>();
}
``


There several problems/inconveniences with above approach, including:

* Fatal error in one of the invocation will stop whole test case and will skip invocations with different types
* You need to repeat function invocation manually for all the parameters you are interested in
* You need two functions to implement the test

Ideally the test case template would be based on nullary function template (like single_test above).
Unfortunately function templates are neither addressable nor can be used as template parameters. To alleviate
the issue the manually registered test case template facility consists of two co-working macros:
__BOOST_TEST_CASE_TEMPLATE_FUNCTION__ and __BOOST_TEST_CASE_TEMPLATE__. Former is used to define the test case
template body, later - to create and register test cases based on it.


The macro __BOOST_TEST_CASE_TEMPLATE_FUNCTION__ requires two arguments: 

# the name of the test case template and 
# the name of the format type parameter

``
  BOOST_TEST_CASE_TEMPLATE_FUNCTION(test_case_name, type_name);
``

[warning Is this snippet really useful??]
[/ snippet 3 deleted and copied below]
``
BOOST_TEST_CASE_TEMPLATE_FUNCTION( test_case_name, type_name )
{
  // test case template body
}
``

The macro __BOOST_TEST_CASE_TEMPLATE_FUNCTION__ is intended to be used in place of nullary function template
signature:

[/snippet4 deleted]
``
template <typename type_name>
void test_case_name()
{
  // test case template body
}
``

The only difference is that the __BOOST_TEST_CASE_TEMPLATE_FUNCTION__ makes the test case template name usable in
the template argument list.


__BOOST_TEST_CASE_TEMPLATE__ requires two arguments: 

# the name of the test case template and 
# Boost.MPL compatible collection of types to instantiate it with. 

The names passed to both macros should be the same.


``
  BOOST_TEST_CASE_TEMPLATE(test_case_name, collection_of_types);
``

__BOOST_TEST_CASE_TEMPLATE__ creates an instance of the test case generator. When passed to the method
`test_suite::add`, the generator produces a separate sub test case for each type in the supplied collection of
types and registers it immediately in the test suite. Each test case is based on the test case template body
instantiated with a particular test type.

The names for the ['sub test cases] are deduced from the macro argument `test_case_name`. If you prefer to assign different test
case names, you need to use the underlying `make_test_case` interface instead. Both test cases creation and
registration is performed in the test module initialization function.

[tip
The test case template facility is preferable to the approach in example above, since execution of each sub
test case is guarded and counted separately. It produces a better test log/results report (in example above in
case of failure you can't say which type is at fault) and allows you to test all types even if one of
them causes termination of the sub test case.
]

[import ../examples/example09.cpp]
[import ../examples/example09.output]
[table:id_example09 Manually registered test case template
  [
    [Code]
    [Output]
  ]
  [
    [[example09]]
    [[example09o]]
  ]
]



[endsect] [/template test cases]

[endsect] [/ test cases]


[#ref_test_outputs][section:test_output Test output ... or let's see what you got for your money]
The output produced by a test module is one of the major assets the __UTF__ brings to users. In comparison with any
kind of manual/assert based solution the __UTF__ provide following services:

* All test errors are reported uniformly[br]
  The test execution monitor along with standardized output from all included
  __testing_tools__ provides uniform reporting for all errors including fatal errors, like memory assess violation and uncaught exceptions.
* Detailed information on the source of an error[br]
  The __UTF__ test tool's based assertion provides as much information as possible about cause of error,
  usually  allowing you to deduce what is wrong without entering the debugger or core analysis.
* Separation of the test errors description (test log) from the results report summary (test results report)[br]
  The information produced during test execution, including all error, warning and info messages from the test
  tools, executed test units notification constitute the test log. By default all entries in the test log are
  directed to the standard output. Once testing is completed the __UTF__ may produce a summary test report with
  different levels of detail. The test report is by default directed to the standard error output.
* Flexibility in what is shown in the output[br]
  The __UTF__ provides the ability to configure what if shown in both the test log and the test report. The
  configuration is supported both at runtime, during test module invocation and at compile time from within a
  test module.
* Flexibility in how output is formatted[br]
  The __UTF__ provides the ability to configure the format of the test module output. At the moment only 2 formats
  are supported by the __UTF__ itself, the well defined public interface allows you to customize an output for
  your purposes almost any way you want.
  
  
[section Test log output]

The test log is produced during the test execution. All entries in the test log are assigned a particular log
level. Only the entries with level that exceeds the ['active log level threshold] actually
appear in the test log output. Log levels are arranged by the 'importance' of the log entries. Here is
the list of all levels in order of increasing 'importance':


[table:id_messages Messages
    [
      [Notifications]
      [Meaning]
    ]
    [
      [Success]
      [This category includes messages that provide information on successfully passed assertions]     
    ]
    [
      [Test tree traversal]
      [This category includes messages that are produced by the __UTF__ core and indicate which test suites/cases are currently being executed or skipped]
    ]
    [
      [General information]
      [This category includes general information massages produced in most cases by a test module author using the
       macro __BOOST_TEST_MESSAGE__]
    ]
    [
      [Warning]
      [This category includes messages produced by failed warning level assertions]
    ]
    [
      [Non fatal error]
      [This category includes messages produced by failed check level assertions]
    ]

    [
      [Uncaught C++ exceptions]
      [This category includes messages that are produced by the __UTF__ and provide detailed information on the C++
       exceptions uncaught by the test case body.
      ]
    ]
    [
      [Non-fatal system error]
      [This category includes messages that are produced by the __UTF__ itself and provides information about caught
       non-fatal system error. For example it includes messages produced in the case of test case timeout or if
       floating  point values calculation errors are caught.
      ]
   ]
   [
      [Fatal system error]
      [This category includes messages produced by failed require level assertions and by the __UTF__ itself in case of
       abnormal test case termination.]
   ]
]

[note 
    The active log level works namely as threshold, not as selector. For the given active log level threshold, all
    test log entries with ['importance] higher than threshold are enabled and all test log entries with
    ['importance] below threshold are disabled.
]

In addition to the levels described above the test log defines two special log levels. The current log level can
be set to:

* All messages
  If active log level threshold is set to this value, all test log entries appear in the output. In practice
  this is equivalent to setting the active log level threshold to ['success information messages]
* Nothing
  If the active log level threshold is set to this value, none of test log entries appear in the output. This log level
  is used to execute a ['silent] test that doesn't produce any test log and only generates a result code indicating whether test failed or passed.


By default the active log level threshold is set to &quot;non fatal error messages&quot; and the test log output
is generated in the human readable format. The active log level threshold and the output format can be configured
at runtime during a test module invocation and at compile time from within a test module using the test log
public interfaces. For example, for automated test module output processing it might be more convenient to use
the XML based format.

In most cases The __UTF__ can't provide an exact location, where system error occurs or uncaught C++ exception
is thrown from. To be able to pinpoint it as close as possible the __UTF__ keeps track of checkpoints - the
location a test module passed through. A test case entrance and exit points, a test tool invocation point the
__UTF__ tracks automatically. Any other checkpoints should be entered by you manually. The test log provides two
macros for this purpose: __BOOST_TEST_CHECKPOINT__ - to specify a ['named] checkpoint 
and __BOOST_TEST_PASSPOINT__ - to specify an ['unnamed] checkpoint.


[endsect] [/test_output]



[/ -------------------------------------------------------------------------------------------------- ]

[section:testing_tool_args Logging tool arguments]

Most of the __testing_tools__ print values of their arguments to the output
stream in some form of log statement. If arguments type does not support 
``
  operator<<(std::ostream&, ArgumentType const&);
``
interface you will get a compilation error. You can either implement above interface or prohibit the __testing_tools__ from logging argument values for
specified type. To do so use following statement on file level before first test case that includes statement
failing to compile:

  BOOST_TEST_DONT_PRINT_LOG_VALUE(ArgumentType)
  
[import examples/example32.cpp]
[import examples/example32.output]
[table:id_example32 BOOST_TEST_DONT_PRINT_LOG_VALUE usage
  [
    [Code]
    [Output]
  ]
  [
    [[example32]]
    [[example32o]]
  ]
]


[heading:log_runtime_config Runtime configuration]

The active log level threshold can be configured at runtime using the parameter __param_log_level__. 
The test log output format can be selected using either parameter __param_log_format__ or the
parameter __param_output_format__.


[endsect] [/section:testing_tool_args]




[/ -------------------------------------------------------------------------------------------------- ]

[#ref_macro_boost_test_message][section:log_test_messages __BOOST_TEST_MESSAGE__]
The macro __BOOST_TEST_MESSAGE__ is intended to be used for the purpose of injecting an additional message into the
__UTF__ test log. These messages are not intended to indicate any error or warning conditions, but rather as
information/status notifications. The macro signature is as follows:

  __BOOST_TEST_MESSAGE__(test_message);

The test_message argument can be as simple as C string literal or any custom expression that you can produce
with in a manner similar to standard `iostream` operation.

[important Messages generated by this tool do not appear in test log output with default value of the active log level
   threshold. For these messages to appear the active log level threshold has to be set to a value below or equal
   to "message".
]

[import examples/example21.cpp]
[import examples/example21.output]
[table:id_example21 __BOOST_TEST_MESSAGE__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example21]]
    [[example21o]]
  ]
]

[endsect] [/section:log_test_messages]




[/ -------------------------------------------------------------------------------------------------- ]
[#ref_BOOST_TEST_CHECKPOINT][section __BOOST_TEST_CHECKPOINT__]


The macro __BOOST_TEST_CHECKPOINT__ is intended to be used to inject [*named] checkpoint position. The
macro signature is as follows:

  __BOOST_TEST_CHECKPOINT__(checkoint_message);

The message formatted at the checkpoint position is saved and reported by the exception logging functions (if any
occurs). Similarly to the __BOOST_TEST_MESSAGE__ the message can be formatted from any standard
output stream compliant components.


[import examples/example22.cpp]
[import examples/example22.output]
[table:id_example22 __BOOST_TEST_CHECKPOINT__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example22]]
    [[example22o]]
  ]
]
[endsect] [/section:log_test_checkpoint]






[/ -------------------------------------------------------------------------------------------------- ]
[#ref_BOOST_TEST_PASSPOINT][section __BOOST_TEST_PASSPOINT__]

The macro __BOOST_TEST_PASSPOINT__ is intended to be used to inject an &quot;unnamed&quot; checkpoint position. The
macro signature is as follows:

  __BOOST_TEST_PASSPOINT__();


Unlike the macro __BOOST_TEST_CHECKPOINT__ this macro doesn't require any message to be
supplied with it. It's just a simple "been there" marker that records file name and line number
code passes through.

[import examples/example23.cpp]
[import examples/example23.output]
[table:id_example23 __BOOST_TEST_PASSPOINT__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example23]]
    [[example23o]]
  ]
]
[endsect] [/section:log_test_passpoint]






[/ -------------------------------------------------------------------------------------------------- ]

[section:log_floating_points Logging floating point type numbers]

It may appear that floating-point numbers are displayed by the __UTF__ with an excessive number of decimal digits.
However the number of digits shown is chosen to avoid apparently nonsensical displays like `[1.00000 != 1.00000]`
when comparing exactly unity against a value which is increased by just one least significant binary digit using
the default precision for float of just 6 decimal digits, given by
`std::numeric_limits<float>::digits10`. The function used for the number of decimal
digits displayed is that proposed for a future C++ Standard,
[@http://www2.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1822.pdf A Proposal to add a max
significant decimal digits value], to be called `std::numeric_limits::max_digits10();`.
For 32-bit floats, 9 decimal digits are needed to ensure a single bit change produces a different decimal digit
string.

So a much more helpful display using 9 decimal digits is thus:
`[1.00000000 != 1.00000012]` showing that the two values are in fact different.


For __IEEE754__ 32-bit float values - 9 decimal digits are shown. For 64-bit __IEEE754__ double - 17 decimal digits. For
__IEEE754__ extended long double using 80-bit - 21 decimal digits. For __IEEE754__ quadruple long double 128-bit, and Sparc
extended long double 128-bit - 36 decimal digits. For floating-point types, a convenient formula to calculate
`max_digits10` is: `2 + std::numeric_limits<FPT>::digits * 3010/10000`;

[note
     Note that a user defined floating point type UDFPT must define
     `std::numeric_limits<UDFPT>::is_specialized = true` and provide an appropriate value
     for `std::numeric_limits<UDFPT>::digits`, the number of bits used for the significand
     or mantissa. For example, for the Sparc extended long double 128, 113 bits are used for the significand (one of
     which is implicit).
]
[endsect] [/section:log_floating_points]








[/ -------------------------------------------------------------------------------------------------- ]
[section:log_human_readable_format Human readable log output format]

The human readable log format is designed to closely match an errors description produced by the Microsoft family
of C++ compilers. This format allows jumping to the error location, if test module output is redirected into IDE
output window. The rest of the log messages are designed to produce the most human friendly description of the
events occurring in test module. This is a default format generated by test modules.

Here the list of events along with corresponding message and the condition that has to be satisfied for it to appear
in the output.

[table:human_readable_log_format_table 
  [
    [Event]
    [Condition]
    [Output]
  ]
  
  [ [On testing start]
    [threshold != log_nothing]
    [`Running <total number of test cases> test case(s) ...`] ]

  [ [On testing start]
    [threshold != log_nothing, show_build_info is set]
    [
[pre Platform: $BOOST_PLATFORM
Compiler: $BOOST_COMPILER
STL     : $BOOST_STDLIB
Boost   : $BOOST_VERSION]] ]

  [ [On abnormal testing termination]
    [threshold <= log_messages]
    [`Test is aborted`] ]

  [ [On test unit start]
    [threshold <= log_test_units]
    [`Entering test <test unit type> <test unit name>`] ]

  [ [On test unit end]
    [threshold <= log_test_units; testing time is reported only if elapsed time is more than 1 mks.]
    [`Leaving test <test unit type> <test unit name>; testing time <value>`] ]

  [ [On skipped test unit]
    [threshold <= log_test_units]
    [`Test <test unit type> <test unit name> is skipped`] ]

  [ [On uncaught C++ exception]
    [threshold <= log_cpp_exception_errors. Checkpoint message is reported only if provided]
    [`unknown location(0): fatal error in <test case name>: <explanation> <last checkpoint location>: last checkpoint: <checkpoint message>`] ]

  [ [On resumable system error]
    [threshold <= log_system_errors. Checkpoint message is reported only if provided]
    [`unknown location(0): fatal error in <test case name>: <explanation> <last checkpoint location>: last checkpoint: <checkpoint message>`] ]

  [ [On fatal system error]
    [threshold <= log_fatal_errors. Checkpoint message is reported only if provided]
    [`unknown location(0): fatal error in <test case name>: <explanation> <last checkpoint location>: last checkpoint: <checkpoint message>`] ]

  [ [On passed test assertion]
    [threshold <= log_successful_tests]
    [`<assertion location>: info: check<assertion expression> passed`] ]

  [ [On failed WARNING level test assertion]
    [threshold <= log_warnings]
    [`<assertion location>: warning in <test case name>: condition <assertion description> is not satisfied`]]

  [ [On failed CHECK level test assertion]
    [threshold <= log_all_errors]
    [`<assertion location>: error in <test case name>: check <assertion description> failed`] ]

  [ [On failed REQUIRE level test assertion]
    [threshold <= log_fatal_errors]
    [`<assertion location>: fatal error in <test case name>: critical check <assertion description> failed`]]

  [ [On test log message]
    [threshold <= log_messages]
    [`<Message content>`]]
]


Advanced __testing_tools__ may produce more complicated error messages.

[endsect] [/ human readable report]





[/ -------------------------------------------------------------------------------------------------- ]
[section:log_xml_format XML based log output format]

This log format is designed for automated test results processing. The test log output XML schema depends on the
active log level threshold.

[warning There is a TO FIX in the doc, what for ?]

[endsect] [/section:log_xml_format ]


[/ -------------------------------------------------------------------------------------------------- ]
[section:log_compil_time_configuration Compile time configuration]

While many test log configuration tasks can be performed at runtime using predefined framework parameters, the
__UTF__ provides a compile time interface as well. The interface gives you full power over what, where and how to 
log. The interface is provided by singleton class ``boost::unit_test::unit_test_log_t`` and is
accessible through local file scope reference to single instance of this class

``boost::unit_test::unit_test_log``


[section:log_ct_output_stream_redirection Log output stream redirection]

If you want to redirect the test log output stream into something different from std::cout use the following
interface:

  boost::unit_test::unit_test_log.set_stream( std::ostream& str );

You can reset the output stream at any time both during the test module initialization and from within test
cases. There are no limitations on number of output stream resets either.

[import examples/example50.cpp]
[import examples/example50.output]
[table:id_example50 Compile-time log output redirection
  [
    [Code]
    [Output]
  ]
  [
    [[example50]]
    [[example50o]]
  ]
]


[warning
  If you redirect test log output stream from global fixture setup, you are [*required] to reset it back to `std::cout`
  during teardown to prevent dangling references access]

[endsect] [/section:log_ct_output_stream_redirection]




[section:log_ct_log_level Log level configuration]
If you need to enforce specific log level from within your test module use the following interface:

  boost::unit_test::unit_test_log.set_threshold_level( boost::unit_test::log_level );


In regular circumstances you shouldn't use this interface, since you not only override default log level, but also
the one supplied at test execution time. Prefer to use runtime parameters for log level selection.


[import examples/example51.cpp]
[import examples/example51.output]
[table:id_example51 Compile-time log level configuration
  [
    [Code]
    [Output]
  ]
  [
    [[example51]]
    [[example51o]]
  ]
]

[endsect] [/section:log_ct_log_level]


[section:log_ct_log_format Predefined log format selection]
The select at compile time the log format from the list of the formats supplied by the __UTF__

   boost::unit_test::unit_test_log.set_format( boost::unit_test::output_format );

In regular circumstances you shouldn't use this interface. Prefer to use runtime parameters for predefined log
format selection.

[import examples/example52.cpp]
[import examples/example52.output]
[table:id_example52 Compile-time log format selection
  [
    [Code]
    [Output]
  ]
  [
    [[example52]]
    [[example52o]]
  ]
]

[endsect] [/section:log_ct_log_format]

[#ref_log_formatter_api][section:custom_log_formatter Custom log format support]

[warning Check what to do on this one]

[endsect] [/section:custom_log_formatter]


[endsect] [/section:log_compil_time_configuration]

[endsect] 


[/
 / Copyright (c) 2003-2014 Gennadiy Rozental (rogeeff at gmail dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:intro Introduction]

[role epigraph Test everything that could possibly break]
[role epigraph --XP maxim]

[role epigraph 
   The acceptance test makes the customer satisfied
   that the software provides the business value that
   makes them willing to pay for it. The unit test makes
   the programmer satisfied that the software does what 
   the programmer thinks it does
]
[role epigraph --XP maxim]

What is the first thing you need to do when you start working on new library/class/program? That's right -
you need to start with the unit test module (I hope you all gave this answer!). Occasionally, you may get 
away with simple test implemented using `assert`s, but any professional developer soon finds this approach
lacking. It becomes clear that it's too time-consuming and tedious for simple, but repetitive unit testing 
tasks and it's too inflexible for most non-trivial ones.

The Boost.Test library provides both an easy to use and flexible set of interfaces for writing test 
programs, organizing tests into simple test cases and test suites, and controlling their runtime execution. 
Some of Boost.Test's interfaces are also useful in production (non-test) environments. 

[/ ##################################################################### ]
[h3 Rationale]

Unit testing tasks arise during many different stages of software development: from initial project 
implementation to its maintenance and later revisions. These tasks differ in their complexity and purpose 
and accordingly are approached differently by different developers. The wide spectrum of tasks in a problem
domain cause many requirements (sometimes conflicting) to be placed on a unit testing framework. These
include:

* Writing a unit test module should be simple and obvious for new users.
* The framework should allow advanced users to perform non-trivial tests.
* Test module should be able to have many small test cases and developer should be able to group them into 
  test suites.
* At the beginning of the development users want to see verbose and descriptive error message, whereas 
  during the regression testing they just want to know if any tests failed.
* For a small test modules run time should prevail over compilation time: user don't want to wait a minute
  to compile a test that takes a second to run.
* For long and complex tests users want to be able to see the test progress.
* Simplest tests shouldn't require an external library.
* For long term usage users of a unit test framework should be able to build it as a standalone library.

The __UTF__ design is based on above rationale and provides versatile facilities to:

* Simplify writing test cases by using various [link boost_test.testing_tools testing tools].
* Organize test cases into a [link boost_test.tests_organization test tree].
* Relieve you from messy error detection, reporting duties and framework runtime parameters processing.

The __UTF__ is intended to be used both for a simple and non trivial testing. It is not intended to be used
with production code, but some of the Boost.Test interfaces can be, including ... 

[warning TOFIX]


[/ ##################################################################### ]
[section The 5mn starter guide]
This section shows a step-by-step guide for writing your very first test, in less than 5mn. 

[h3 Building boost.test]
Before being able to do anything, you have to build boost.test. 

```
> cd boost_path
> boostrap.bat
> b2 --with-test --prefix=``$``boost_installation_prefix install
```

or for Unix operating system (including OSX)
```
> cd boost_path
> ./boostrap.sh
> ./b2 --with-test --prefix=``$``boost_installation_prefix install
```

More documentation can be found [@http://www.boost.org/more/getting_started/index.html here]. Now you are ready
to build against the __UTF__.


[h3 Writing your first test]
Let's start by creating the minimal skeleton for our [link ref_test_module test module]. This minimal skeleton in the file `test_file.cpp`, 
looks like this:

``
#define __BOOST_TEST_DYN_LINK__
#define __BOOST_TEST_MAIN__
#include <boost/test/unit_test.hpp>

__BOOST_AUTO_TEST_CASE__(first_test)
{
  __BOOST_CHECK__(true);
  
  int i = 1;
  __BOOST_CHECK_EQUAL__(i, 1);
}
`` 

The command/macro __BOOST_AUTO_TEST_CASE__ declares a test named `first_test`, which in turn will run the content of `first_test` inside the 
controlled testing environment. This test checks that `true` is `true` and that `i` equals `1`, often useful. 

Before continuing in adding value to the test module itself, let's now build the test module contained in [*an unique]
[footnote with more than one file, one line should be changed] file. For building the test module, we have two more tools: the compiler and 
the linker, which should be configured appropriately:

* configure the compiler to find the header file `boost/test/unit_test.hpp`.
* configure the linker to find the boost.test library that were previously compiled.

We will see now three common use cases.

[h4 Using GCC/Clang]

```
g++ -o test_executable \
    -I ``$``boost_installation_prefix/include \
    -L ``$``boost_installation_prefix/lib \
    -l boost_unit_test_framework \
    test_file.cpp
```

The command line is similar for `clang`. 
As you can see, the previous example is not exactly an example to follow for bigger projects, but this is more
than enough to build our own unique test file into an appropriate test module. 



[h4 Using Visual Studio]

# open Visual and create an empty C++ console Win32 project
# add the file `test_file.cpp`
# go to the properties of the project,
  # under C/C++/General/include directories, add $`boost_installation_prefix/include`
  # under Link/General/Additional library paths, add $`boost_installation_prefix/lib`

A nice property on Windows is [link boost_test.users_guide.link_references.link_boost_test_no_lib auto-linking], 
so you do not need to specify the library `boost_unit_test_framework` to the
linker. 

[h4 Using CMake]
Let's be more independent of the platform, and use [@http://www.cmake.org cmake]. Let's paste the following content in a `CMakeLists.txt` 
at the same location than our previous test file `test_file.cpp`:

```
cmake_minimum_required(VERSION 2.8.11)
project(first_test_with_cmake)
enable_testing()

# looking for the boost installation path
find_package(Boost COMPONENTS unit_test_framework)

# creates the executable
add_executable(test_executable test_file.cpp)

# declares a test with our executable
add_test(NAME test1 COMMAND test_executable)

```

We will now create the build directory for this project (separate directory), configure and build the project,
as follow:
```
> cd ``$``test_path
> mkdir build /*< we create a directory dedicated to the build, to avoid any pollution of the sources with the temporary
                  build files >*/
> cd build
> cmake -DBOOST_ROOT=``$``boost_installation_prefix .. /*< configuration of the project, the `BOOST_ROOT` configuration element indicates the 
                                                           Boost module of `cmake` where to find our installation >*/
> cmake --build . /*< this command builds the project, cmake drives a native tool that is configured on the 
                      previous command line >*/
> ctest           /*< runs the tests declared in the project and prints a report >*/
```

[h4 Really less than 5mn]
You should now be convinced that starting using the __UTF__ is straighforward. As any framework, __UTF__ also provides 
a lot of functionalities that you will discover when needed. 



[endsect] [/ 5mn starter]



[/ ##################################################################### ]
[section How to read this documentation?]

Without further ado, I'd like to start ... but where? It's not obvious what is the best order to describe
the framework. One can use bottom up approach, starting with with basics and going up to cover real 
interfaces based on them. The downside is that you'll have to dig through the multiple pages of information
you may not never need in real life. One can follow the order of test program execution. From test 
initialization to test tree construction to the report and log generation. This also unfortunately may not
be most clear way. The Boost.Test __UTF__ is very flexible and a lot of details of various test 
initialization options may not necessarily be important for average user, while understanding test output
is.

Well ... This is a User's Guide after all. Let's go by what *you*, as a user, need to know to 
successfully use the __UTF__. Thus I follow the order of decisions you have to make and order
of complexity of the problems you might encounter. If you find yourself faced with some unclear term feel 
free to jump directly to the __part_glossary__ section, where short definitions for all used terms were
collected. And if you want to jump right into coding the __section_tutorial__ section would be a better
place to start.

The __UTF__ has several usage variants. And the first decision you have to make is which one to use. These
variants are covered in section dedicated to [link boost_test.users_guide Usage variants]. The next step, probably the most important 
for you, is to start writing test cases, bind them in test suites and implement your checks. First two 
topics are covered in __section_test_organization__ section, while __testing_tools__ section arms you with
rich set of tools enough to implement almost arbitrary check you need.

Next you'll learn how to understand and manipulate the __UTF__ output in a __test_outputs__ section. 
At that point you should be able to build and run most simple test modules and almost inevitable find a need
to configure how the test module is executed. Whether you want to change output format, select which test 
case to run or run test cases in random order these and may other runtime configuration parameters are 
described in [*Runtime configuration] section.

One of the first non trivial things you might want to add to your test module is test fixture. Fixture
support is covered in __section_test_fixture__ section. Usually the default test module initialization
will work just fine, but if you want to implement some custom initialization or change how default 
initialization behaves you need to first look in [*Test module initialization] section. Here you'll learn
about various options the __UTF__ provides for you to customize this behaviour.

Finally you might want to learn about how the __UTF__ implements entry points into the test modules. This
is especially important if you intend to implement the `main` function yourself and not use the one 
provided by the __UTF__. The [*Test runners] section covers this subject. Different usage variants employ
slightly different approached to implementing test module entry points and presents slightly different
interfaces. This section intended for advanced user some of the details of the implementation are described
there.

[endsect] [/How to read]



[endsect] [/ Introduction]

[/ EOF]

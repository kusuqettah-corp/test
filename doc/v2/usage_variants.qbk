[/
 / Copyright (c) 2003-2014 Gennadiy Rozental 
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[/ ##################################################################### ]
[section:usage_variants Usage variants]

The __UTF__ supports three different usage variants:

# [link boost_test.users_guide.usage_variants.single_header The single-header variant]
# [link boost_test.users_guide.usage_variants.static_lib    The static library variant]
# [link boost_test.users_guide.usage_variants.shared_lib    The shared library variant]

In most cases you shouldn't have problems deciding which one to use, since there are
clear reasons why would you prefer each one. Following sections should help you with the decision.

[h3:single_header Single-header usage variant]

If you prefer to avoid the compilation of standalone library, you should use the 
single-header variant of the __UTF__. This variant only requires you to include, 
as it follows from its name, the single header: `#include <boost/test/included/unit_test.hpp>`
and there is no need to link with any library. There are several ways to perform 
the initialization, but the simplest way is this:
``
  #define __BOOST_TEST_MODULE__ test module name
  #include <boost/test/included/unit_test.hpp>
``
__BOOST_TEST_MODULE__ macro needs to be defined *before* the include and should be set to 
test module name. This name can include spaces and does not need to be wrapped in quotes. 

The limitation of single header variant is that you can only implement this way 
test modules with a single translation unit. 

For more details on customization for this usage variant you can check this [/TOFIX] section

[h3:static_lib Static library usage variant]
For most users, who has an access to prebuild static library [footnote these files are distributed with the packaging systems on Linux and OSX for instance] 
of the __UTF__ or can build [/TOFIX make a link] it themselves, 
following usage can be most versatile and simple approach. This usage variant entails two steps. 

# First you need to add following line to all translation units in a test module:
  ``
    #include <boost/test/unit_test.hpp>
  ``
  and *only one* translation unit should include following lines
  ``
    #define __BOOST_TEST_MODULE__ test module name
    #include <boost/test/unit_test.hpp>
  ``
  __BOOST_TEST_MODULE__ macro needs to be defined *before* the include and should be set to 
  test module name. This name can include spaces and does not need to be wrapped in quotes. 
# The second step is to link with the __UTF__ static library.

The flip side of this usage variant is that each test module is going to be statically linked
with __UTF__, which might be something you interested to avoid. Also this usage variant has 
limited options for test runners. For more information about these configuration options check 
this [/TOFIX] section.

[h3:shared_lib Shared library usage variant]
In the project with large number of test modules the static library variant of the __UTF__ may
cause you to waste a lot of disk space. The solution is to link test module dynamically with the 
__UTF__ [link boost_test.users_guide.build_boost_test built] as a shared library. 
This usage variant entails two steps. 

# First you need to add following lines to all translation units in a test module:
  ``
    #define __BOOST_TEST_DYN_LINK__
    #include <boost/test/unit_test.hpp>
  ``
  and *only one* translation unit should include following lines
  ``
    #define __BOOST_TEST_MODULE__ test module name
    #define __BOOST_TEST_DYN_LINK__
    #include <boost/test/unit_test.hpp>
  ``
  __BOOST_TEST_MODULE__ macro needs to be defined *before* the include and should be set to 
  test module name. This name can include spaces and does not need to be wrapped in quotes. 

# The second step is to link with the __UTF__ shared library.

The flip of this usage variant is that you will need to make sure the __UTF__ shared library
is accessible at runtime to a test module.

Shared library usage variant facilitates custom test runners. For more information about this 
check this [/TOFIX] section.

[endsect] [/Usage Variants]





[/ ##################################################################### ]
[section:build_boost_test Building the __UTF__]

In case you would like to use the shared or static variants of the __UTF__, the __UTF__ needs to be built. 
Building the __UTF__ is in fact quite easy.

In the sequel,

* `$boost_path` refers to the location where the boost archive was deflated
* `$boost_installation_prefix` refers to the location where you want to install the __UTF__

[info By default, the static and dynamic variant will be built for your operating system]

More documentation about Boost's build system can be found [@http://www.boost.org/more/getting_started/index.html here]. 

[h3 Windows]
You need to have a compilation toolchain. [Visual Studio Express] is such one, freely available from the 
Microsoft website. Once installed, 

For building 32bits libraries, type:
```
> cd $boost_path
> boostrap.bat
> b2 --with-test --prefix=``$``boost_installation_prefix install
```

For building 64bits libraries, type:
```
> cd $boost_path
> boostrap.bat
> b2 address-model=64 architecture=x86 --with-test --prefix=``$``boost_installation_prefix install
```



[h3 Linux/OSX]
For Unix/Linux/OSX operating system, the build of the __UTF__ is very similar to the one on Windows:
```
> cd $boost_path
> ./boostrap.sh
> ./b2 --with-test --prefix=``$``boost_installation_prefix install
```



[ensect] [/ building boost test]

[/ EOF]

[#ref_execution_monitor][section:execution_monitor The Execution Monitor]

ion and make sure that no user or system originated exceptions are being thrown
by it. Uniform exception reporting is also may be convenient. That's the purpose of the Boost.Test's
['Execution Monitor].

The Execution Monitor is a lower-level component of the Boost Test Library. It is the base for implementing all
other Boost.Test components, but also can be used standalone to get controlled execution of error-prone functions
with a uniform error notification. The Execution Monitor calls a user-supplied function in a controlled
environment, relieving users from messy error detection.

The Execution Monitor usage is demonstrated in the example [headerref exec_mon_example.cpp]. Additional examples are 
in <xref linkend="pem"/> or __UTF__.

[heading Design Rationale]
The Execution Monitor design assumes that it can be used when no (or almost no) memory available. Also the
Execution Monitor is intended to be portable to as many platforms as possible.

[section The Execution Monitor compilation variants and procedures]

[heading Implementation]

The Execution Monitor is implemented in two modules: one header file and one source file.

* [headerref execution_monitor.hpp `boost/test/execution_monitor.hpp`]: defines abstract execution monitor 
  interfaces and implements execution exception.
* `boost/test/impl/execution_monitor.ipp`: provides the Execution Monitor implementation for all supported configurations, 
  including Microsoft structured exception based, UNIX signals.

You may use this component in both debug and release modes, but in release mode the Execution Monitor won't
catch Microsoft C runtime debug events.


[heading Standalone library compilation]

To compile the Execution Monitor as standalone library compose it using only 
`execution_monitor.cpp` as a source file. Alternatively you can add this file directly to the 
list of source files for your project. Boost Test Library's components include this file as a part of their 
compilation procedure.

[heading Direct include]

In some cases you may want to include the source file along with header file into your sources. But be aware that
to be able to catch all kinds of standard exceptions and to implement signal handling logic this file will bring
a lot of dependencies.
[endsect] [/compilation variants and procedures]

[/ ###########################################]
[section The Execution Monitor user's guide]

The Execution Monitor is designed to solve the problem of executing potentially dangerous function that may result
in any number of error conditions, in monitored environment that should prevent any undesirable exceptions to 
propagate out of function call and produce consistent result report for all 
<link linkend="execution-monitor.user-guide.monitor-outcomes">outcomes</link>. The Execution Monitor is able to 
produce informative report for all standard C++ exceptions and intrinsic types. All other exceptions are reported as
unknown. If you prefer different message for your exception class or need to perform any action, the Execution 
Monitor supports <link linkend="execution-monitor.user-guide.errors-reporting">custom exception translators</link>.
There are several other <link linkend="execution-monitor.user-guide.monitor-params">parameters</link> of the 
monitored environment can be configured by setting appropriate properties of the Execution Monitor.

All symbols in the Execution Monitor implementation are located in the namespace boost. To use the Execution
Monitor you need to:

* ``#include <boost/test/execution_monitor.hpp>``
* Make an instance of [classref execution_monitor]
* Optionally register custom exception translators for exception classes which require special processing.

[section Monitored function execution]

To start the monitored function, invoke the method [memberref execution_monitor::execute] and pass 
the monitored function as an argument. If the call succeeds, the method returns the result code produced by the
monitored function. If any of the following conditions occur:

* Uncaught C++ exception
* Hardware or software signal, trap, or other exception
* Timeout reached
* Debug assert event occurred (under Microsoft Visual C++ or compatible compiler)

then the method throws the [classref execution_exception]. The exception contains unique 
[enumref error_code] value identifying the error condition and the detailed message that can be used to report 
the error.

[endsect]
  
[/ ###########################################]
[section The execution monitor parameters]

All parameters are implemented as public read-write properties of class <classname>execution_monitor</classname>.
   
The <firstterm>p_catch_system_errors</firstterm> property is a boolean flag (default value is true) specifying whether
or not <classname>execution_monitor</classname> should trap system level exceptions (second category in above list).
Set this property to false, for example, if you wish to force coredump file creation. The Unit Test Framework 
provides a runtime parameter --catch_system_errors=yes to alter the behavior in monitored test cases. 


The <firstterm>p_auto_start_dbg</firstterm> property is a boolean flag (default value is false) specifying whether or
not <classname>execution_monitor</classname> should try to attach debugger in case system error is caught.

The [memberref execution_monitor::p_timeout property] is an integer timeout (in seconds) for monitored function execution. Use
this parameter to monitor code with possible deadlocks or indefinite loops. This feature is only available for some 
operating systems (not yet Microsoft Windows).

The <firstterm>p_use_alt_stack</firstterm> property is a boolean flag (default value is false) specifying whether or
not <classname>execution_monitor</classname> should use an alternative stack for the 
<functionname>sigaction</functionname> based signal catching. When enabled the signals are delivered to the 
<classname>execution_monitor</classname> on a stack different from current execution stack, which is safer in case 
if it is corrupted by monitored function. For more details on alternative stack handling see appropriate 
<ulink url="http://www.opengroup.org/onlinepubs/000095399/functions/sigaltstack.html">manuals</ulink>.

The `p_detect_fp_exceptions` property is a boolean flag (default value is false) specifying 
whether or not [classref execution_monitor] should install hardware traps for the floating point 
exception on platforms where it's supported.

[endsect]

[/ ###########################################]
[section Errors reporting and translation]
If you need to report an error inside monitored function execution you have to throw an exception. Do not use the
<classname>execution_exception</classname> - it's not intended to be used for this purpose. The simplest choice is 
to use one of the following C++ types as an exception:

* C string
* `std:string`
* any exception class in std::exception hierarchy

In case if you prefer to use your own exception classes or can't govern what exceptions are generated by monitored 
function and would like to see proper error message in a report, the Execution Monitor allows you to register the
translator for any exception class. You can register as many independent translators as you like. See 
<classname>execution_monitor</classname> specification for requirements on translator function. Also see below 
for usage example.
   
Finally, if you need to abort the monitored function execution without reporting any errors, you can throw an 
exception <classname>execution_aborted</classname>. As a result the execution is aborted and zero result code
is produced by the method <methodname>execution_monitor::execute</methodname>.
    
[endsect]


[/ ###########################################]
[section Memory leaks detection]

The Execution Monitor provides a limited ability to detect memory leaks during program execution, and to
break program execution on specific memory allocation order-number (1 - first allocation of memory in program, 2 -
second and so on). Unfortunately this feature is, at the moment, implemented only for the Microsoft family of
compilers (and Intel, if it employs Microsoft C Runtime Library). Also it can not be tuned per instance of the
monitor and is only triggered globally and reported after the whole program execution is done. In a future this
ought to be improved. An interface is composed from two free functions residing in namespace boost::debug:

``
void detect_memory_leaks( bool on_off );
void break_memory_alloc( long mem_alloc_order_num );
``

Use function detect_memory_leaks to switch memory leaks detection on/off. Use break_memory_alloc to break a
program execution at allocation specified by mem_alloc_order_num argument. The Unit Test Framework
provides a runtime parameter (--detect_memory_leaks=0 or 1 or N>1, where N is memory allocation number) 
allowing you to manage this feature during monitored unit tests.

[endsect]

[endsect] [/ user guide]


[endsect]
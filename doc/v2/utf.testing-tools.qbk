[section:testing_tools The __UTF__ testing tools]
The __UTF__'s supplies a toolbox of testing tools to ease creation and maintenance of test programs and
provide a  uniform error reporting mechanism. The toolbox supplied in most part in a form of macro and function
declarations. While the functions can be called directly, the usual way to use testing tools is via convenience
macros. All macros arguments are calculated once, so it's safe to pass complex expressions in their place.
All tools automatically supply an error location: a file name and a line number. The testing tools are intended
for unit test code rather than library or production code, where throwing exceptions, using `assert()`,
`boost::concept_check` or `BOOST_STATIC_ASSERT()` may be more suitable
ways to detect and report errors. For list of all supplied testing tools and usage examples see the reference.

[include testing_tools/assertions_severity_levels.qbk]
[include testing_tools/custom_predicates.qbk]
[include testing_tools/testing_output_streams.qbk]
[include testing_tools/testing_floating_points.qbk]


[section:testing_tool_ref __UTF__ testing tools reference]


[table
  [
    [Assertions]
    [Short description]
  ] 
  
  [/ ###############################################################################################]
  [
    [__BOOST_LEVEL__]
    [Simple validation of a boolean predicate value.]
  ]

  [/ ###############################################################################################]
  [
    [__BOOST_LEVEL_BITWISE_EQUAL__]
    [Bitwise equality test of two elements.]
  ]
  
  [/ ###############################################################################################]
  [
    [__BOOST_LEVEL_EQUAL__]
    [Equality test of two elements.]
  ]

  [/ ###############################################################################################]
  [
    [__BOOST_LEVEL_EQUAL_COLLECTIONS__]
    [Element-wise equality test of two collections.]
  ]
  
]





[/ ###############################################################################################]
[#ref_BOOST_level][section:assertion_boost_level `BOOST_<level>`]


``
  BOOST_WARN(predicate);
  BOOST_CHECK(predicate);
  BOOST_REQUIRE(predicate);
``

These tools are used to validate the predicate value. The only parameter for these tools is a boolean predicate
value that gets validated. It could be any expression that could be evaluated and converted to boolean value. The
expression gets evaluated only once, so it's safe to pass complex expression for validation.

[import examples/example34.cpp]
[import examples/example34.output]
[table:id_example34 `BOOST_<level>` usage
  [
    [Code]
    [Output]
  ]
  [
    [[example34]]
    [[example34o]]
  ]
]

See also:

* __BOOST_LEVEL_MESSAGE__

[endsect]


[/ ###############################################################################################]
[#ref_BOOST_level_BITWISE_EQUAL][section:assertion_boost_level_bitwise_eq `BOOST_<level>_BITWISE_EQUAL`]


``
  BOOST_WARN_BITWISE_EQUAL(left, right);
  BOOST_CHECK_BITWISE_EQUAL(left, right);
  BOOST_REQUIRE_BITWISE_EQUAL(left, right);
``

These tools are used to perform bitwise comparison of two values. The check shows all positions where left and
right value's bits mismatch.

The first parameter is the left compared value. The second parameter is the right compared value. Parameters are
not required to be of the same type, but warning is issued if their type's size does not coincide.

[import examples/example33.cpp]
[import examples/example33.output]
[table:id_example33 __BOOST_LEVEL_BITWISE_EQUAL__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example33]]
    [[example33o]]
  ]
]

See also:

* __BOOST_LEVEL_EQUAL__

[endsect]

[/ ###############################################################################################]
[#ref_BOOST_level_EQUAL][section:assertion_boost_level_eq `BOOST_<level>_EQUAL`]

``
  BOOST_WARN_EQUAL(left, right);
  BOOST_CHECK_EQUAL(left, right);
  BOOST_REQUIRE_EQUAL(left, right);
``

Check performed by these tools is the same as the one performed by `__BOOST_LEVEL__(left == right)`.
The difference is that the mismatched values are reported as well.

[note It is bad idea to use these tools to compare floating point values. Use __BOOST_LEVEL_CLOSE__ or
      __BOOST_LEVEL_CLOSE_FRACTION__ tools instead.
]
[import examples/example35.cpp]
[import examples/example35.output]
[table:id_example35 __BOOST_LEVEL_EQUAL__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example35]]
    [[example35o]]
  ]
] 


See also:

* __BOOST_LEVEL__
* __BOOST_LEVEL_CLOSE__
* __BOOST_LEVEL_NE__
* __BOOST_LEVEL_EQUAL_COLLECTIONS__

[endsect]

[/ ###############################################################################################]
[#ref_BOOST_level_EQUAL_COLLECTIONS][section:assertion_boost_level_eq_collections `BOOST_<level>_EQUAL_COLLECTIONS`]

``
  BOOST_WARN_EQUAL_COLLECTIONS(left_begin, left_end, right_begin, right_end);
  BOOST_CHECK_EQUAL_COLLECTIONS(left_begin, left_end, right_begin, right_end);
  BOOST_REQUIRE_EQUAL_COLLECTIONS(left_begin, left_end, right_begin, right_end);
``

These tools are used to perform an element by element comparison of two collections. They print all mismatched
positions, collection elements at these positions and check that the collections have the same size. The first two 
parameters designate begin and end of the first collection. The two last parameters designate begin and end of the
second collection.

[import examples/example36.cpp]
[import examples/example36.output]
[table:id_example36 __BOOST_LEVEL_EQUAL_COLLECTIONS__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example36]]
    [[example36o]]
  ]
]


See also:

* __BOOST_LEVEL_EQUAL__

[endsect]





[#ref_BOOST_level_CLOSE][h3 `BOOST_<level>_CLOSE`]


``
  BOOST_WARN_CLOSE(left, right, tolerance);
  BOOST_CHECK_CLOSE(left, right, tolerance);
  BOOST_REQUIRE_CLOSE(left, right, tolerance);
``

These tools are used to check on closeness using strong relationship defined by the predicate
``check_is_close( left, right, tolerance )`` 

To check for the weak relationship use
__BOOST_LEVEL_PREDICATE__ family of tools with explicit `check_is_close` invocation.


The first parameter is the ['left] compared value. The second parameter is the
['right] compared value. Last third parameter defines the tolerance for the comparison in
[link boost_test.testing_tools.testing_floating_points [*percentage units]].

[note It is required for left and right parameters to be of the same floating point type. You will need to explicitly
      resolve any type mismatch to select which type to use for comparison.
]

[note Note that to use these tools you need to include additional header `floating_point_comparison.hpp`.
]

[import examples/example42.cpp]
[import examples/example42.output]
[table:id_example42 __BOOST_LEVEL_CLOSE__ usage with small values
  [
    [Code]
    [Output]
  ]
  [
    [[example42]]
    [[example42o]]
  ]
]

[import examples/example43.cpp]
[import examples/example43.output]
[table:id_example43 __BOOST_LEVEL_CLOSE__ usage with big values
  [
    [Code]
    [Output]
  ]
  [
    [[example43]]
    [[example43o]]
  ]
]

See also:

* __BOOST_LEVEL_CLOSE_FRACTION__
* __BOOST_LEVEL_SMALL__
* __BOOST_LEVEL_EQUAL__
* [link boost_test.testing_tools.testing_floating_points Floating point comparison algorithms]


[#ref_BOOST_level_CLOSE_FRACTION][h3 `BOOST_<level>_CLOSE_FRACTION`]

``
  BOOST_WARN_CLOSE_FRACTION(left, right, tolerance);
  BOOST_CHECK_CLOSE_FRACTION(left, right, tolerance);
  BOOST_REQUIRE_CLOSE_FRACTION(left, right, tolerance);
``

These tools are used to check on closeness using strong relationship defined by the predicate
``check_is_close(left, right, tolerance)`` 

To check for the weak relationship use __BOOST_LEVEL_PREDICATE__ family of tools with explicit `check_is_close` invocation.

The first parameter is the ['left] compared value. The second parameter is the
['right] compared value. Last third parameter defines the tolerance for the comparison as
[link boost_test.testing_tools.testing_floating_points [*fraction of absolute values being compared]].

[note It is required for left and right parameters to be of the same floating point type. You will need to explicitly
      resolve any type mismatch to select which type to use for comparison.]

[note Note that to use these tools you need to include additional header `floating_point_comparison.hpp`.]

[import examples/example44.cpp]
[import examples/example44.output]
[table:id_example44 __BOOST_LEVEL_CLOSE_FRACTION__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example44]]
    [[example44o]]
  ]
]

See also:

* __BOOST_LEVEL_CLOSE__
* __BOOST_LEVEL_SMALL__
* __BOOST_LEVEL_EQUAL__
* [link boost_test.testing_tools.testing_floating_points Floating point comparison algorithms]





[#ref_BOOST_level_EXCEPTION][h3 `BOOST_<level>_EXCEPTION`]

``
  BOOST_WARN_EXCEPTION(expression, exception, predicate);
  BOOST_CHECK_EXCEPTION(expression, exception, predicate);
  BOOST_REQUIRE_EXCEPTION(expression, exception, predicate);
``

These tools are used to perform an exception detection and validation check. Tools execute the supplied expression
and validate that it throws an exception of supplied class (or the one derived from it) that complies with the 
supplied predicate. If the expression throws any other unrelated exception, doesn't throw at all or 
predicate evaluates to false, check fails. In comparison with __BOOST_LEVEL_THROW__ tools these
allow performing more fine-grained checks. For example: make sure that an expected exception has specific 
error message.

[import examples/example37.cpp]
[import examples/example37.output]
[table:id_example37 __BOOST_LEVEL_EXCEPTION__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example37]]
    [[example37o]]
  ]
]

See also:

* __BOOST_LEVEL_THROW__


[#ref_BOOST_level_GE][h3 `BOOST_<level>_GE`]

``
  BOOST_WARN_GE(left, right);
  BOOST_CHECK_GE(left, right);
  BOOST_REQUIRE_GE(left, right);
``

Check performed by these tools is the same as the one performed by `__BOOST_LEVEL__( left >= right )`.
The difference is that the argument values are reported as well.

[import examples/example57.cpp]
[import examples/example57.output]
[table:id_example57 __BOOST_LEVEL_GE__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example57]]
    [[example57o]]
  ]
]

See also:

* __BOOST_LEVEL_LE__
* __BOOST_LEVEL_LT__
* __BOOST_LEVEL_GT__



[#ref_BOOST_level_GT][h3 `BOOST_<level>_GT`]


``
  BOOST_WARN_GT(left, right);
  BOOST_CHECK_GT(left, right);
  BOOST_REQUIRE_GT(left, right);
``

Check performed by these tools is the same as the one performed by __BOOST_LEVEL__`( left > right )`.
The difference is that the argument values are reported as well.

[import examples/example58.cpp]
[import examples/example58.output]
[table:id_example58 __BOOST_LEVEL_GT__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example58]]
    [[example58o]]
  ]
]
See also:

* __BOOST_LEVEL_LE__
* __BOOST_LEVEL_LT__
* __BOOST_LEVEL_GE__


[#ref_BOOST_level_LE][h3 `BOOST_<level>_LE`]

``
  BOOST_WARN_LE(left, right);
  BOOST_CHECK_LE(left, right);
  BOOST_REQUIRE_LE(left, right);
``

Check performed by these tools is the same as the one performed by `__BOOST_LEVEL__( left <= right )`.
The difference is that the argument values are reported as well.

[import examples/example55.cpp]
[import examples/example55.output]
[table:id_example55 __BOOST_LEVEL_LE__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example55]]
    [[example55o]]
  ]
]

See also:

* __BOOST_LEVEL_LE__
* __BOOST_LEVEL_GE__
* __BOOST_LEVEL_GT__


[#ref_BOOST_level_LT][h3 `BOOST_<level>_LT`]

``
  BOOST_WARN_LT(left, right);
  BOOST_CHECK_LT(left, right);
  BOOST_REQUIRE_LT(left, right);
``

Check performed by these tools is the same as the one performed by `__BOOST_LEVEL__( left < right )`.
The difference is that the argument values are reported as well.

[import examples/example56.cpp]
[import examples/example56.output]
[table:id_example56 __BOOST_LEVEL_LT__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example56]]
    [[example56o]]
  ]
]

See also:

* __BOOST_LEVEL_LE__
* __BOOST_LEVEL_GE__
* __BOOST_LEVEL_GT__


[#ref_BOOST_level_MESSAGE][h3 `BOOST_<level>_MESSAGE`]


``
  BOOST_WARN_MESSAGE(predicate, message);
  BOOST_CHECK_MESSAGE(predicate, message);
  BOOST_REQUIRE_MESSAGE(predicate, message);
``

These tools perform exactly the same check as __BOOST_LEVEL__ tools. The only difference is that
instead of generating an error/confirm message these use the supplied one.

The first parameter is the boolean expression. The second parameter is the message reported in case of check
failure. The message argument can be constructed of components of any type supporting the 
`std::ostream& operator<< (std::ostream&)`.

[import examples/example38.cpp]
[import examples/example38.output]
[table:id_example38 __BOOST_LEVEL_MESSAGE__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example38]]
    [[example38o]]
  ]
]

See also:

* __BOOST_LEVEL__



[#ref_BOOST_level_NE][h3 `BOOST_<level>_NE`]


``
  BOOST_WARN_NE(left, right);
  BOOST_CHECK_NE(left, right);
  BOOST_REQUIRE_NE(left, right);
``

Check performed by these tools is the same as the one performed by `__BOOST_LEVEL__( left != right )`.
The difference is that the matched values are reported as well.

[import examples/example54.cpp]
[import examples/example54.output]
[table:id_example54 __BOOST_LEVEL_NE__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example54]]
    [[example54o]]
  ]
]

See also:

* __BOOST_LEVEL_EQUAL__



[#ref_BOOST_level_NO_THROW][h3 `BOOST_<level>_NO_THROW`]


``
  BOOST_WARN_NO_THROW(expression);
  BOOST_CHECK_NO_THROW(expression);
  BOOST_REQUIRE_NO_THROW(expression);
``

These tools are used to perform a "no throw" check. Tools execute the supplied expression and validate that it does
not throw any exceptions. Error would be reported by the framework even if the statement appear directly in test
case body and throw any exception. But these tools allow proceeding further with test case in case of failure.

If check is successful, tools may produce a confirmation message, in other case they produce an error message in
a form ``error in <test-case-name>;exception was thrown by <expression>``

The only parameter is an expression to execute. You can use `do {} while(0)` block if you want to execute more than one
statement.

[import examples/example39.cpp]
[import examples/example39.output]
[table:id_example39 __BOOST_LEVEL_NO_THROW__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example39]]
    [[example39o]]
  ]
]


See also:

* __BOOST_LEVEL_THROW__



[#ref_BOOST_level_PREDICATE][h3 `BOOST_<level>_PREDICATE`]


``
  BOOST_WARN_PREDICATE(predicate, arguments_list);
  BOOST_CHECK_PREDICATE(predicate, arguments_list);
  BOOST_REQUIRE_PREDICATE(predicate, arguments_list);
``

These are generic tools used to validate an arbitrary supplied predicate functor (there is a compile time limit on
predicate arity defined by the configurable macro `BOOST_TEST_MAX_PREDICATE_ARITY`). To
validate zero arity predicate use __BOOST_LEVEL__ tools. In other cases prefer theses tools. The
advantage of these tools is that they show arguments values in case of predicate failure.

The first parameter is the predicate itself. The second parameter is the list of predicate arguments each wrapped
in round brackets (`BOOST_PP` sequence format).

[import examples/example40.cpp]
[import examples/example40.output]
[table:id_example40 __BOOST_LEVEL_PREDICATE__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example40]]
    [[example40o]]
  ]
]

[note Note difference in error log from __BOOST_LEVEL__]

See also:

* __BOOST_LEVEL__


[#ref_BOOST_level_SMALL][h3 `BOOST_<level>_SMALL`]


``
  BOOST_WARN_SMALL(value, tolerance);
  BOOST_CHECK_SMALL(value, tolerance);
  BOOST_REQUIRE_SMALL(value, tolerance);
``

These tools are used to check that supplied value is small enough. The "smallness" is defined by absolute value
of the tolerance supplied as a second argument. Use these tools with caution. To compare to values on closeness 
it's preferable to use __BOOST_LEVEL_CLOSE__ tools instead.

The first parameter is the value to check. The second parameter is the tolerance.

[note Note that to use these tools you need to include additional header `floating_point_comparison.hpp`.]

[import examples/example41.cpp]
[import examples/example41.output]
[table:id_example41 __BOOST_LEVEL_SMALL__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example41]]
    [[example41o]]
  ]
]


See also:

* __BOOST_LEVEL_CLOSE__
* __BOOST_LEVEL_CLOSE_FRACTION__
* [link boost_test.testing_tools.testing_floating_points Floating point comparison algorithms]



[#ref_BOOST_level_THROW][h3 `BOOST_<level>_THROW`]


``
  BOOST_WARN_THROW(expression, exception);
  BOOST_CHECK_THROW(expression, exception);
  BOOST_REQUIRE_THROW(expression, exception);
``

These tools are used to perform an exception detection check. Tools execute the supplied expression and validate
that it throws an exception of supplied class (or the one derived from it) or it's child. If the statement 
throws any other unrelated exception or doesn't throw at all, check fails.

If check is successful, the tool produces a confirmation message, in other case it produces an error message in a
form `error in <test-case-name>: exception <exception> expected`.

The first parameter is the expression to execute. Use `do{} while(0)` block if you want to execute more than one
statement. The second parameter is an expected exception.

[import examples/example45.cpp]
[import examples/example45.output]
[table:id_example45 __BOOST_LEVEL_THROW__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example45]]
    [[example45o]]
  ]
]

See also:

* __BOOST_LEVEL_NO_THROW__


[#ref_BOOST_ERROR][h3 `BOOST_ERROR`]

``
  BOOST_ERROR(message);
``

__BOOST_ERROR__ tool behave the same way as `__BOOST_CHECK_MESSAGE__(false, message )`. This tool is used for
an unconditional error counter increasing and message logging. 

The only tool's parameter is an error message to log.

[import examples/example46.cpp]
[import examples/example46.output]
[table:id_example46 __BOOST_ERROR__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example46]]
    [[example46o]]
  ]
]

See also:

* __BOOST_LEVEL__




[#ref_BOOST_FAIL][h3 `BOOST_FAIL`]

``
  BOOST_FAIL(message);
``

`__BOOST_FAIL__(message)` behave the same way as [link ref_BOOST_level_MESSAGE `BOOST_REQUIRE_MESSAGE`]`(false, message)`. This tool is used for an
unconditional error counter increasing, message logging and the current test case aborting. 

The only tool's parameter is an error message to log.

[import examples/example47.cpp]
[import examples/example47.output]
[table:id_example47 __BOOST_FAIL__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example47]]
    [[example47o]]
  ]
]

See also:

* __BOOST_LEVEL__
* __BOOST_LEVEL_MESSAGE__




[#ref_BOOST_IS_DEFINED][h3 `BOOST_IS_DEFINED`]

``
  BOOST_IS_DEFINED(symbol);
``

Unlike the rest of the tools in the toolbox this tool does not perform the logging itself. Its only purpose
is to check at runtime whether or not the supplied preprocessor symbol is defined. Use it in combination with
__BOOST_LEVEL__ to perform and log validation. Macros of any arity could be checked. To check the
macro definition with non-zero arity specify dummy arguments for it. See below for example.

The only tool's parameter is a preprocessor symbol that gets validated.

[import examples/example48.cpp]
[import examples/example48.output]
[table:id_example48 __BOOST_IS_DEFINED__ usage
  [
    [Code]
    [Output]
  ]
  [
    [[example48]]
    [[example48o]]
  ]
]


See also:

* __BOOST_LEVEL__


[endsect] [/ testing_tool_ref]

[endsect] [/ testing tools]

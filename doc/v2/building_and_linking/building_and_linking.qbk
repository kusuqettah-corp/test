[section:build Building a test module with the __UTF__]

There are two tasks should be performed before actual testing is able to start:

* The test tree needs to be built: unless automated test units registration is used, the tests that should be run and their relationship
  should be indicated.
* Custom ['test module initialization] needs to be performed. This includes
  initialization of the code under test and custom tune-up of the __UTF__ parameters (for example the test log or the
  test results report output streams redirection, some command line parameters passed to the test module, etc.).

The part of the __UTF__ dedicated for this purpose is called [link boost_test.beyond_basics.build.module_initialization ['the test module initialization]] function. 

[note Note that alternatively to ['module initialization], global __section_test_fixture__ may be employed.]

The ['module initialization] and the way the test module is linked against the __UTF__ are closely related. The method used to link 
against the __UTF__ are often lead by considerations external to the tests themselves (compilation time, size of the generated binaries, etc). However,
the functions of the ['module initialization] involved in, say static and dynamic linking, will not be the same. To cover many possible usages,
the __UTF__ handles several different variants of linking, and indirectly the tools for proper ['module initialization] corresponding to each
of these variants are provided.


[/ ######################################################## ]
[include module_initialization.qbk]

[/ ######################################################## ]
[section:usage_variants Linking with the __UTF__]

The __UTF__ supports four different usage variants:

# The static library variant
# The dynamic library variant
# The single-header variant
# The external test runner variant

Unlike the Buridan's donkey though, you shouldn't have problems deciding which one to use, since there are
clear reasons why would you prefer each one.

In most cases to compile a test module based on the __UTF__ all you need to include is just the [headerref boost/test/unit_test.hpp single header]

``
  #include <boost/test/unit_test.hpp>
``

This header includes internally most of the other headers that contains the __UTF__ definitions. Some advanced features, 
like the floating point comparison or the logged expectations testing, are defined in independent headers and need to be included explicitly.

[include variant_static_lib.qbk]
[include variant_dynamic_lib.qbk]
[include variant_single_header.qbk]
[include variant_external_runner.qbk]

[endsect] [/section:usage_variants]

[/ ######################################################## ]
[/ reference of the macros]
[include link_reference.qbk]

[endsect] [/section:building_utf]

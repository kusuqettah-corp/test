[section:tests_organization Test organization... or the house that Jack built]

If you look at many legacy test modules, big chance is that it's implemented as one big test function that
consists of a mixture of check and output statements. Is there anything wrong with it? Yes. There are various
disadvantages in single test function approach:

* One big function tends to become really difficult to manage if the number of checks exceeds a reasonable limit
  (true for any large function). What is tested and where - who knows?
* Many checks require similar preparations. This results in code repetitions within the test function.
* If a fatal error or an exception is caused by any checks within the test function the rest of tests are
  skipped and there is no way to prevent this.
* No way to perform only checks for a particular subsystem of the tested unit.
* No summary of how different subsystems of the tested unit performed under in the test.

The above points should make it clear that it's preferable to split [*test module] into smaller units.
These units are [*test cases].

To solve test tree creation problem the __UTF__ provides facilities for
[*test suite creation].



In some cases it's desirable to allow some ['expected] failures in test case without failing a
test module. To support this request The __UTF__ allows specifying the number of
[*expected failures] in a test case.


[section:test_cases Test cases]
A test case has to be constructed based on some kind of
function and registered in a test tree, so that the test runner knows how to invoke it. There are different
possible designs for the test case construction problem: inheritance from the predefined base class, specifically
named member function and so on. The __UTF__ opted to avoid classed altogether and to use the 
least intrusive ['generic callback] approach.
The facility the __UTF__ provides, requires specific function signature and allows
adopting any function or function object that matches the signature as a test case. The signatures the __UTF__
supports are:

* Nullary function
* Unary function
* Nullary function template

Generic test case construction design used by the __UTF__ causes the test case implementation (test function body)
and test case creation/registration points to be remote. As a result you may forget to register the test case
and it's never going to be executed, even though it's present in test file. To alleviate this issue
the __UTF__ presents facilities for automated (in place) test case creation and registration in the test tree. These
facilities sacrifice some generality and work for selected test function signatures only. But the result is that
library users are relieved from the necessity to manually register test cases. These facilities are the most
user-friendly and are recommended to be used whenever possible. In addition they support automated registration
of test suites, thus allowing whole test tree to be created without any use of manual registration.

The single test module may mix both automated and manual test case
registration. In other words, within the same test module you can have both test cases implemented remotely and
registered manually in the test module initialization function and test cases that are registered automatically at
implementation point.


[section:test_organization_nullary Nullary function based test case]

The most widely used are test cases based on a nullary function. These include nullary free functions, nullary
function objects created with `boost::bind` and nullary `boost::function`
instances. The simplest is a free function and the __UTF__ provides facilities to create a free function based test
case that is automatically registered. Here are the two construction interfaces:

* [*Test case with automated registration]
* [*Manually registered test case]
 
 
[#ref_BOOST_AUTO_TEST_CASE][h3  Nullary function based test case with automated registration]

To create a nullary free function cased test case, which is registered in place of implementation, employ the
macro __BOOST_AUTO_TEST_CASE__.
 
``
  BOOST_AUTO_TEST_CASE(test_case_name);
``

The macro is designed to closely mimic nullary free function syntax. Changes that are required to make an
existing test case, implemented as a free function, registered in place are illustrated in the following
example (compare with <xref linkend="utf.user-guide.test-organization.manual-nullary-test-case.example01"/>):


[import examples/example06.cpp]
[import examples/example06.output]
[table:id_example06 Nullary function based test case with automated registration
  [
    [Code]
    [Output]
  ]
  [
    [[example06]]
    [[example06o]]
  ]
]


With this macro you don't need to implement the initialization function at all. The macro creates and
registers the test case with the name free_test_function automatically.

[#ref_BOOST_TEST_CASE][h3 Manually registered nullary function based test case]

To create a test case manually, employ the macro __BOOST_TEST_CASE__:

``
  BOOST_TEST_CASE(test_function);
``


__BOOST_TEST_CASE__ creates an instance of the class `boost::unit_test::test_case` and returns a pointer to the
constructed instance. The test case name is deduced from the macro argument test_function. If you prefer to
assign a different test case name, you have to use the underlying make_test_case interface instead. To
register a new test case, employ the method `test_suite::add`. Both test case creation and registration are
performed in the test module initialization function.


Here is the simplest possible manually registered test case. This example employs the original test module
initialization function specification. A single test case is created and registered in the master test suite.
Note that the free function name is passed by address to the macro __BOOST_TEST_CASE__`.

[import examples/example01.cpp]
[import examples/example01.output]
[table:id_example01 Nullary free function manually registered
  [
    [Code]
    [Output]
  ]
  [
    [[example01]]
    [[example01o]]
  ]
]

A test case can be implemented as a method of a class. In this case a pointer to the class instance has to be
bound to the test method to create a test case. You can use the same instance of the class for multiple test
cases. The __UTF__ doesn't take an ownership of the class instance and you are required to manage the class
instance lifetime yourself.

[warning
 The class instance can't be defined in the initialization function scope, since it becomes invalid as
 soon as the test execution exits it. It needs to be either defined statically/globally or managed using a
 shared pointer.
]

[import examples/example02.cpp]
[import examples/example02.output]
[table:id_example02 Nullary method of a class bound to global class instance and manually registered
  [
    [Code]
    [Output]
  ]
  [
    [[example02]]
    [[example02o]]
  ]
]

[import examples/example03.cpp]
[import examples/example03.output]
[table:id_example03 Nullary method of a class bound to shared class instance and manually registered
  [
    [Code]
    [Output]
  ]
  [
    [[example03]]
    [[example03o]]
  ]
]

If you do not need to reuse the test class instance and can't or do not wish to create test class
instance globally it may be easier and safer to create an instance on the stack of free function:

[import examples/example04.cpp]
[import examples/example04.output]
[table:id_example04 Nullary method of a class bound to local class instance inside free function
  [
    [Code]
    [Output]
  ]
  [
    [[example04]]
    [[example04o]]
  ]
]

If you have to perform the same set of tests with different sets of parameters you may want to base your test
case on a function with arguments and bind particular parameters during test case creation.

[warning
 If you bind parameters by reference or pointer, the referenced value can't have local storage in the
     test module initialization function.
]
 
 
The example below employs the alternative test module initialization function specification:

[import examples/example05.cpp]
[import examples/example05.output]
[table:id_example05 Binary free function bound to set of different parameter pairs
  [
    [Code]
    [Output]
  ]
  [
    [[example05]]
    [[example05o]]
  ]
]


The __UTF__ also presents an alternative method for parameterized test case creation, which is covered in 
[link test_organization_unary].

[endsect]
 
[section:test_organization_unary Unary function based test case]

Some tests are required to be repeated for a series of different input parameters. One way to achieve this is
manually register a test case for each parameter as in example above. You can also invoke a test function with
all parameters manually from within your test case, like this:

[/ snippet1 deleted qnd copied below]
``
void single_test( int i )
{
  BOOST_CHECK( /* test assertion */ );
}

void combined_test()
{
  int params[] = { 1, 2, 3, 4, 5 };
  std::for_each( params, params+5, &single_test );
}
``

The __UTF__ presents a better solution for this problem: the unary function based test case, also referred as
['parameterized test case]. The unary test function can be a free function, unary functor (for example created
with `boost::bind`) or unary method of a class with bound test class instance). The test function is converted
into test case using the macro `BOOST_PARAM_TEST_CASE`. The macro expects a collection of parameters (passed as
two input iterators) and an unary test function:

``
  BOOST_PARAM_TEST_CASE(test_function, params_begin, params_end);
``
 

`BOOST_PARAM_TEST_CASE` creates an instance of the test case generator. When passed to the method test_suite::add,
the generator produces a separate sub test case for each parameter in the parameters collection and registers
it immediately in a test suite. Each test case is based on a test function with the parameter bound by value,
even if the test function expects a parameter by reference. The fact that parameter value is stored along with
bound test function releases you from necessity to manage parameters lifetime. For example, they can be defined
in the test module initialization function scope.

All sub test case names are deduced from the macro argument test_function. If you prefer to assign different
names, you have to use the underlying make_test_case interface instead. Both test cases creation and
registration are performed in the test module initialization function.

The parameterized test case facility is preferable to the approach in the example above, since execution of
each sub test case is guarded and counted independently. It produces a better test log/results report (in
example above in case of failure you can't say which parameter is at fault) and allows you to test against
all parameters even if one of them causes termination a particular sub test case.

In comparison with a manual test case registration for each parameter approach the parameterized test case
facility is more concise and easily extendible.

In following simple example the same test, implemented in `free_test_function`, is
performed for 5 different parameters. The parameters are defined in the test module initialization function
scope. The master test suite contains 5 independent test cases.


[import examples/example07.cpp]
[import examples/example07.output]
[table:id_example07 Unary free function based test case
  [
    [Code]
    [Output]
  ]
  [
    [[example07]]
    [[example07o]]
  ]
]



Next example is similar, but instead of a free function it uses a method of a class. Even though parameters are
passed into test method by reference you can still define them in the test module initialization  function scope.
This example employs the alternative test module initialization function specification.

[import examples/example08.cpp]
[import examples/example08.output]
[table:id_example08 Unary class method based test case
  [
    [Code]
    [Output]
  ]
  [
    [[example08]]
    [[example08o]]
  ]
]

[endsect] [/test case with arity]



[#ref_BOOST_AUTO_TEST_CASE_TEMPLATE][section:test_organization_templates Test cases for templates]

To test a template based component it's frequently necessary to perform the same set of checks for a
component instantiated with different template parameters. The __UTF__ provides the ability to create a series of
test cases based on a list of desired types and function similar to nullary function template. This facility is
called test case template. Here are the two construction interfaces:

* Test case template with automated registration
* Manually registered test case template

[h3 Test case template with automated registration]

To create a test case template registered in place of implementation, employ the macro
__BOOST_AUTO_TEST_CASE_TEMPLATE__. This facility is also called ['auto test case template].

``
BOOST_AUTO_TEST_CASE_TEMPLATE(test_case_name, formal_type_parameter_name, collection_of_types);
``

The macro __BOOST_AUTO_TEST_CASE_TEMPLATE__ requires three arguments:

# `test_case_name` The test case template name: unique test cases template identifier
# `formal_type_parameter_name` The name of a formal template parameter:
         name of the type the test case template is instantiated with
# The collection of types to instantiate test case template with: arbitrary MPL sequence

[import examples/example10.cpp]
[import examples/example10.output]
[table:id_example10 Test case template with automated registration
  [
    [Code]
    [Output]
  ]
  [
    [[example10]]
    [[example10o]]
  ]
]

[h3 Test case template with manual registration]
One way to perform the same set of checks for a component instantiated with different template parameters is
illustrated in the following example:

[/snippet2 deleted and copied below]
``
template <typename T>
void single_test()
{
  BOOST_CHECK( /* test assertion */ );
}

void combined_test()
{
  single_test<int>();
  single_test<float>();
  single_test<unsigned char>();
}
``


There several problems/inconveniencies with above approach, including:

* Fatal error in one of the invocation will stop whole test case and will skip invocations with different types
* You need to repeat function invocation manually for all the parameters you are interested in
* You need two functions to implement the test

Ideally the test case template would be based on nullary function template (like single_test above).
Unfortunately function templates are neither addressable nor can be used as template parameters. To alleviate
the issue the manually registered test case template facility consists of two co-working macros:
`BOOST_TEST_CASE_TEMPLATE_FUNCTION` and `BOOST_TEST_CASE_TEMPLATE`. Former is used to define the test case
template body, later - to create and register test cases based on it.


The macro `BOOST_TEST_CASE_TEMPLATE_FUNCTION` requires two arguments: the name of the test case template and the
name of the format type parameter:

``
  BOOST_TEST_CASE_TEMPLATE_FUNCTION(test_case_name, type_name);
``

[warning Is this snippet really useful??]
[/ snippet 3 deleted and copied below]
``
BOOST_TEST_CASE_TEMPLATE_FUNCTION( test_case_name, type_name )
{
  // test case template body
}
``

The macro `BOOST_TEST_CASE_TEMPLATE_FUNCTION` is intended to be used in place of nullary function template
signature:

[/snippet4 deleted]
``
template <typename type_name>
void test_case_name()
{
  // test case template body
}
``

The only difference is that the `BOOST_TEST_CASE_TEMPLATE_FUNCTION` makes the test case template name usable in
the template argument list.


`BOOST_TEST_CASE_TEMPLATE` requires two arguments: the name of the test case template and Boost.MPL compatible
collection of types to instantiate it with. The names passed to both macros should be the same.


``
  BOOST_TEST_CASE_TEMPLATE(test_case_name, collection_of_types);
``

`BOOST_TEST_CASE_TEMPLATE` creates an instance of the test case generator. When passed to the method
`test_suite::add`, the generator produces a separate sub test case for each type in the supplied collection of
types and registers it immediately in the test suite. Each test case is based on the test case template body
instantiated with a particular test type.

The names for the ['sub test cases] are deduced from the macro argument `test_case_name`. If you prefer to assign different test
case names, you need to use the underlying `make_test_case` interface instead. Both test cases creation and
registration is performed in the test module initialization function.

[tip
The test case template facility is preferable to the approach in example above, since execution of each sub
test case is guarded and counted separately. It produces a better test log/results report (in example above in
case of failure you can't say which type is at fault) and allows you to test all types even if one of
them causes termination of the sub test case.
]

[import examples/example09.cpp]
[import examples/example09.output]
[table:id_example09 Manually registered test case template
  [
    [Code]
    [Output]
  ]
  [
    [[example09]]
    [[example09o]]
  ]
]



[endsect] [/template test cases]

[endsect] [/ test cases]


[section:test_organization_test_suite Test suite]
If you consider test cases as leaves on the test tree, the test suite can be considered as branch and the master
test suite as a trunk. Unlike real trees though, our tree in many cases consists only of leaves attached
directly to the trunk. This is common for all test cases to reside directly in the master test suite. If you do
want to construct a hierarchical test suite structure the __UTF__ provides both manual and automated
test suite creation and registration facilities:

# Test suite with automated registration
# Manually registered test suite

In addition the __UTF__ presents a notion of[*Master Test Suite]. The most important
reason to learn about this component is that it provides an ability to access command line arguments supplied 
to a test module.

[#ref_BOOST_AUTO_TEST_SUITE][h3 Test suites with automated registration]
The solution the __UTF__ presents for automated test suite creation and registration is designed to facilitate
multiple points of definition, arbitrary test suites depth and smooth integration with automated test case creation 
and registration. This facility should significantly simplify a test tree construction process in comparison with 
manual explicit registration case.


The implementation is based on the order of file scope variables definitions within a single compilation unit.
The semantic of this facility is very similar to the namespace feature of C++, including support for test suite 
extension. To start test suite use the macro __BOOST_AUTO_TEST_SUITE__. To end test suite use the macro
__BOOST_AUTO_TEST_SUITE_END__. The same test suite can be restarted multiple times inside the same test file or in a
different test files. In a result all test units will be part of the same test suite in a constructed test tree.

``
  BOOST_AUTO_TEST_SUITE(test_suite_name);
  BOOST_AUTO_TEST_SUITE_END();
``

Test units defined in between test suite start and end declarations become members of the test suite. A test
unit always becomes the member of the closest test suite declared. Test units declared at a test file scope
become members of the master test suite. There is no limit on depth of test suite inclusion.


This example creates a test tree that matches exactly the one created in the manual test suite registration
example.

[import examples/example12.cpp]
[import examples/example12.output]
[table:id_example12 Test suites with automated registration
  [
    [Code]
    [Output]
  ]
  [
    [[example12]]
    [[example12o]]
  ]
]
As you can see test tree construction in this example is more straightforward and automated.


In the example below, the test suite `test_suite` consists of two parts. Their definition is remote and is separated by another
test case. In fact these parts may even reside in different test files. The resulting test tree remains the same. As
you can see from the output both `test_case1` and `test_case2` reside in the same test suite `test_suite`.

[import examples/example53.cpp]
[import examples/example53.output]
[table:id_example53 Example of test suite extension using automated registration facility
  [
    [Code]
    [Output]
  ]
  [
    [[example53]]
    [[example53o]]
  ]
]



[h3 Test suites with manual registration]
To create a test suite manually you need to create an instance of `boost::unit_test::test_suite` class, register
it in test tree and populate it with test cases (or lower level test suites).

[h4 Test unit registration interface]


The __UTF__ models the notion of test case container - test suite - using class `boost::unit_test::test_suite`. For
complete class interface reference check advanced section of this documentation. Here you should only be
interested in a single test unit registration interface:

``
  void test_suite::add( test_unit* tc, counter_t expected_failures = 0, int timeout = 0 );
``

The first parameter is a pointer to a newly created test unit. The second optional parameter -
expected_failures  - defines the number of test assertions that are expected to fail within the test unit. By
default no errors are  expected.

[caution
  Be careful when supplying a number of expected failures for test suites. By default the __UTF__ calculates the
  number of expected failures in test suite as the sum of appropriate values in all test units that constitute
  it. And it rarely makes sense to change this.
]

The third optional parameter - timeout - defines the timeout value for the test unit. As of now the __UTF__
isn't able to set a timeout for the test suite execution, so this parameter makes sense only for test case
registration. By default no timeout is set. See the method
`boost::execution_monitor::execute` for more details about the timeout value.

To register group of test units in one function call, the `boost::unit_test::test_suite` provides another `add`
interface covered in the advanced section of this documentation.
[warning find the related advanced doc]

[#ref_BOOST_TEST_SUITE][h4 Test suite instance construction]


To create a test suite instance manually, employ the macro __BOOST_TEST_SUITE__. It hides all implementation
details and you only required to specify the test suite name:

``
  BOOST_TEST_SUITE(test_suite_name);
``

__BOOST_TEST_SUITE__ creates an instance of the class `boost::unit_test::test_suite` and returns a pointer to the
constructed instance. Alternatively you can create an instance of class `boost::unit_test::test_suite` yourself.

[caution `boost::unit_test::test_suite` instances have to be allocated on the heap and the compiler won't allow you
      to create one on the stack.
]

Newly created test suite has to be registered in a parent one using add interface. Both test suite creation and
registration is performed in the test module initialization function.

The example below creates a test tree, which can be represented by the following hierarchy:
[$../img/class-hier.jpg]

[import examples/example11.cpp]
[import examples/example11.output]
[table:id_example11 Manually registered test suites
  [
    [Code]
    [Output]
  ]
  [
    [[example11]]
    [[example11o]]
  ]
]




[section:master_test_suite Master Test Suite]


As defined in introduction section the master test suite is a root node of a test tree. Each test module built
with the __UTF__ always has the master test suite defined. The __UTF__ maintain the master test suite instance
internally. All other test units are registered as direct or indirect children of the master test suite.

``
namespace boost {
namespace unit_test {
class master_test_suite_t : public test_suite
{
public:
  int argc;
  char** argv;
};

} // namespace unit_test
} // namespace boost
``


To access single instance of the master test suite use the following interface:

``
namespace boost {
namespace unit_test {
namespace framework {

master_test_suite_t& master_test_suite();

} // namespace framework
} // namespace unit_test
} // namespace boost
``

[h4 Command line arguments access interface]

Master test suite implemented as an extension to the regular test suite, since it maintains references to the
command line arguments passed to the test module. To access the command line arguments use

``
boost::unit_test::framework::master_test_suite().argc
boost::unit_test::framework::master_test_suite().argv
``

In below example references to the command line arguments are accessible either as an initialization function
parameters or as members of the master test suite. Both references point to the same values. A test module that
uses the alternative initialization function specification can only access command line arguments through the
master test suite.

[note This interface for runtime parameter access is temporary. It's planned to be updated once runtime
      parameters support is redesigned.
]

Returning to the free function example, let's modify initialization function to check for absence of any
test module arguments.

[import examples/example13.cpp]
[import examples/example13.output]
[table:id_example13 Command line access in initialization function
  [
    [Code]
    [Output]
  ]
  [
    [[example13]]
    [[example13o]]
  ]
]

[#ref_BOOST_TEST_MODULE][h4 Naming the ['Master test suite]]

The master test suite is created with default name ['Master Test Suite]. There are two methods two
reset the name to a different value: using the macro __BOOST_TEST_MODULE__
and from within the test module initialization function. Former is used for test modules that don't have the
manually implemented initialization function. Following examples illustrate these methods.


[import examples/example14.cpp]
[import examples/example14.output]
[table:id_example14 Naming master test suite using the macro __BOOST_TEST_MODULE__
  [
    [Code]
    [Output]
  ]
  [
    [[example14]]
    [[example14o]]
  ]
]

If the macro __BOOST_TEST_MODULE__ is defined, the test module initialization
function is [*automatically generated] and the
macro value becomes the name of the master test suite. The name may include spaces.

[import examples/example15.cpp]
[import examples/example15.output]
[table:id_example15 Naming master test suite explicitly in the test module initialization function
  [
    [Code]
    [Output]
  ]
  [
    [[example15]]
    [[example15o]]
  ]
]


Without the `BOOST_TEST_MAIN` and the __BOOST_TEST_MODULE__ flags defined, the test module initialization 
function has to be manually implemented. The master test suite name can be reset at any point within this function.

[warning link to the definition of `BOOST_TEST_MAIN`]

[endsect] [/ command line interface]

[section Expected failures specification]

While in a perfect world all test assertions should pass in order for a test module to pass, in some situations
it is desirable to temporarily allow particular tests to fail. For example, where a particular feature is not
implemented yet and one needs to prepare a library for the release or when particular test fails on some
platforms. To avoid a nagging red box in regression tests table, you can use the expected failures feature.


This feature allows specifying an expected number of failed assertions per test unit. The value is specified
during test tree construction, and can't be updated during test execution.

The feature is not intended to be used to check for expected functionality failures. To check that a particular
input is causing an exception to be thrown use __BOOST_LEVEL_THROW__ family of testing
tools.

The usage of this feature should be limited and employed only after careful consideration. In general you should
only use this feature when it is necessary to force a test module to pass without actually fixing the problem.
Obviously, an excessive usage of expected failures defeats the purpose of the unit test. In most cases it only
needs be applied temporarily.

You also need to remember that the expected failure specification is per test case. This means that any failed
assertion within that test case can satisfy the expected failures quota. Meaning it is possible for an
unexpected failure to occur to satisfy this quota.


[note If an assertion at fault is fixed and passed, while an expected failures specification still present, the test
    case is going to fail, since the number of failures is smaller than expected.
]

[h3 Usage with manually registered test cases]

To set the value of expected failures for the manually registered test unit pass it as a second argument for the
`test_suite::add` call during test unit registration.

[import examples/example16.cpp]
[import examples/example16.output]
[table:id_example16 Expected failures specification for manually registered test case
  [
    [Code]
    [Output]
  ]
  [
    [[example16]]
    [[example16o]]
  ]
]

[#ref_BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES][h3 Usage with automatically registered test cases]

To set the number of expected failures for the automatically registered test unit use the macro
__BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES__ before the test case definition.

``
BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES(test_case_name, number_of_expected_failures);
``

You can use this macro both on a file scope and inside a test suite. Moreover you can use it even if name of test
units coincide in different test suites. Expected failures specification applies to the test unit belonging to the same 
test suite where __BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES__ resides.


[import examples/example17.cpp]
[import examples/example17.output]
[table:id_example17 Expected failures specification for automatically registered test case
  [
    [Code]
    [Output]
  ]
  [
    [[example17]]
    [[example17o]]
  ]
]


[endsect] [/ expected failures]
[endsect] [/test suite]
[endsect] [/ test organization]

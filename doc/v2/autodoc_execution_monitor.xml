<?xml version="1.0" standalone="yes"?>
<library-reference><header name="/Users/raffi/Personnel/boost_github/libs/test/example/exec_mon_example.cpp">
<struct name="my_exception1"><data-member name="m_res_code"><type>int</type></data-member>
<method-group name="public member functions">
</method-group>
<constructor specifiers="explicit"><parameter name="res_code"><paramtype>int</paramtype></parameter></constructor>
</struct><struct name="my_exception2"><data-member name="m_res_code"><type>int</type></data-member>
<method-group name="public member functions">
</method-group>
<constructor specifiers="explicit"><parameter name="res_code"><paramtype>int</paramtype></parameter></constructor>
</struct><function name="cpp_main"><type>int</type><parameter name="argc"><paramtype>int</paramtype></parameter><parameter name=""><paramtype>char *</paramtype></parameter></function>
</header>
<header name="boost/test/debug.hpp">
<para>defines portable debug interfaces </para><para>Intended to standardize interface of programs with debuggers </para><namespace name="boost">
<namespace name="debug">
<struct name="dbg_startup_info"><purpose>Collection of data, which is used by debugger starter routine. </purpose><data-member name="pid"><type>long</type><purpose>pid of a program to attach to </purpose></data-member>
<data-member name="break_or_continue"><type>bool</type><purpose>what to do after debugger is attached </purpose></data-member>
<data-member name="binary_path"><type>unit_test::const_string</type><purpose>path to executable for current process </purpose></data-member>
<data-member name="display"><type>unit_test::const_string</type><purpose>if debugger has a GUI, which display to use (on UNIX) </purpose></data-member>
<data-member name="init_done_lock"><type>unit_test::const_string</type><purpose>path to a uniquly named lock file, which is used to pause current application while debugger is being initialized </purpose></data-member>
</struct><typedef name="dbg_starter"><purpose>Signature of debugger starter routine. Takes an instance of dbg_startup_into as only argument. </purpose><type>boost::function&lt; void(<classname>dbg_startup_info</classname> const &amp;)&gt;</type></typedef>
<function name="under_debugger"><type>bool</type><purpose>Checks if programs runs under debugger. </purpose><description><para>
</para></description><returns><para>true if current process is under debugger. False otherwise </para></returns></function>
<function name="debugger_break"><type>void</type><purpose>Cause program to break execution in debugger at call point. </purpose></function>
<function name="set_debugger"><type>std::string</type><parameter name="dbg_id"><paramtype>unit_test::const_string</paramtype><description><para>Unique id for debugger configuration (for example, gdb) </para></description></parameter><parameter name="s"><paramtype>dbg_starter</paramtype><default>dbg_starter()</default><description><para>Optional starter routine for selected configuration (use only you want to define your own configuration) </para></description></parameter><purpose>Specifies which debugger to use when attaching and optionally what routine to use to start that debugger. </purpose><description><para>There are many different debuggers avaialable for different platforms. Some of them also can be used in a different setups/configuratins. For example, gdb can be used in plain text mode, inside ddd, inside (x)emacs or in a separate xterm window. Boost.Test identifies each configuration with unique string. Also different debuggers configurations require different routines which is specifically tailored to start that debugger configuration. Boost.Test comes with set of predefined configuration names and corresponding routines for these configurations:<itemizedlist>
<listitem><para>TODO</para></listitem></itemizedlist>
</para><para>You can use this routine to select which one of the predefined debugger configurations to use in which case you do not need to provide starter routine (the one provided by Boost.Test will be used). You can also use this routine to select your own debugger by providing unique configuration id and starter routine for this configuration.</para><para>

</para></description><returns><para>Id of previosly selected debugger configuration </para></returns></function>
<function name="attach_debugger"><type>bool</type><parameter name="break_or_continue"><paramtype>bool</paramtype><default>true</default><description><para>tells what we wan to do aftr the debugger is attached. If true - process execution breaks in the point in invocation of this function. Otherwise execution continues, but now it is under the debugger </para></description></parameter><purpose>Attaches debugger to the current process. </purpose><description><para>Using currently selected debugger, this routine attempts to attach the debugger to this process. 

</para></description><returns><para>true if debugger successfully attached. False otherwise </para></returns></function>
<function name="detect_memory_leaks"><type>void</type><parameter name="on_off"><paramtype>bool</paramtype><description><para>boolean switch </para></description></parameter><parameter name="report_file"><paramtype>unit_test::const_string</paramtype><default>unit_test::const_string()</default><description><para>file, where the report should be directed to </para></description></parameter><purpose>Switches on/off memory leaks detection. </purpose><description><para>On platforms where memory leak detection is possible inside of running application (at the moment this is only Windows family) you can switch this feature on and off using this interface. In addition you can specify the name of the file to write a report into. Otherwise the report is going to be generated in standard error stream. 
</para></description></function>
<function name="break_memory_alloc"><type>void</type><parameter name="mem_alloc_order_num"><paramtype>long</paramtype><description><para>Specific memory allocation number </para></description></parameter><purpose>Causes program to break execution in debugger at specific allocation point. </purpose><description><para>On some platforms/memory managers (at the moment only on Windows/Visual Studio) one can tell a C Runtime to break on specific memory allocation. This can be used in combination with memory leak detection (which reports leaked memory allocation number) to locate the place where leak initiated. 
</para></description></function>
</namespace>
</namespace>
</header>
<header name="boost/test/debug_config.hpp">
<para>user's config for Boost.Test debugging support </para><para>This file is intended to be edited by end user to specify varios macros, which configure debugger interface Alterntively you can set these parameters in your own sources/makefiles </para></header>
<header name="boost/test/execution_monitor.hpp">
<para>Defines public interface of the Execution Monitor and related classes. </para><namespace name="boost">
<class name="execution_exception"><purpose>This class is used to report any kind of an failure during execution of a monitored function inside of <classname alt="boost::execution_monitor">execution_monitor</classname>. </purpose><description><para>The instance of this class is thrown out of execution_monitor::execute invocation when failure is detected. Regardless of a kind of failure occured the instance will provide a uniform way to catch and report it.</para><para>One important design rationale for this class is that we should be ready to work after fatal memory corruptions or out of memory conditions. To facilitate this class never allocates any memory and assumes that strings it refers to are either some constants or live in a some kind of persistent (preallocated) memory. </para></description><struct name="location"><purpose>Simple model for the location of failure in a source code. </purpose><data-member name="m_file_name"><type>const_string</type><purpose>File name. </purpose></data-member>
<data-member name="m_line_num"><type>size_t</type><purpose>Line number. </purpose></data-member>
<data-member name="m_function"><type>const_string</type><purpose>Function name. </purpose></data-member>
<method-group name="public member functions">
</method-group>
<constructor specifiers="explicit"><parameter name="file_name"><paramtype>char const *</paramtype><default>0</default></parameter><parameter name="line_num"><paramtype>size_t</paramtype><default>0</default></parameter><parameter name="func"><paramtype>char const *</paramtype><default>0</default></parameter></constructor>
</struct><constructor><parameter name="ec"><paramtype>error_code</paramtype><description><para>error code </para></description></parameter><parameter name="what_msg"><paramtype>const_string</paramtype><description><para>error message </para></description></parameter><parameter name="location"><paramtype><classname>location</classname> const &amp;</paramtype><description><para>error location </para></description></parameter><purpose>Constructs instance based on message, location and error code. </purpose><description><para>
</para></description></constructor>
<enum name="error_code"><enumvalue name="no_error"><default>= 0</default><purpose>for completeness only; never returned </purpose></enumvalue><enumvalue name="user_error"><default>= 200</default><purpose>user reported non-fatal error </purpose></enumvalue><enumvalue name="cpp_exception_error"><default>= 205</default><purpose>see note (1) above </purpose></enumvalue><enumvalue name="system_error"><default>= 210</default><purpose>see note (2) above </purpose></enumvalue><enumvalue name="timeout_error"><default>= 215</default><purpose>only detectable on certain platforms </purpose></enumvalue><enumvalue name="user_fatal_error"><default>= 220</default><purpose>user reported fatal error </purpose></enumvalue><enumvalue name="system_fatal_error"><default>= 225</default><purpose>see note (2) above </purpose></enumvalue><purpose>These values are sometimes used as program return codes. The particular values have been chosen to avoid conflicts with commonly used program return codes: values &lt; 100 are often user assigned, values &gt; 255 are sometimes used to report system errors. Gaps in values allow for orderly expansion. </purpose><description><para><note><para>(1) Only uncaught C++ exceptions are treated as errors. If a function catches a C++ exception, it never reaches the <classname alt="boost::execution_monitor">execution_monitor</classname>.</para></note>
The implementation decides what is a system_fatal_error and what is just a system_exception. Fatal errors are so likely to have corrupted machine state (like a stack overflow or addressing exception) that it is unreasonable to continue execution.</para><para><note><para>(2) These errors include Unix signals and Windows structured exceptions. They are often initiated by hardware traps. </para></note>
</para></description></enum>
</class><class name="execution_monitor"><purpose>Function execution monitor. </purpose><description><para>This class is used to uniformly detect and report an occurrence of several types of signals and exceptions, reducing various errors to a uniform <classname alt="boost::execution_exception">execution_exception</classname> that is returned to a caller.</para><para>The executiom_monitor behavior can be customised through a set of public parameters (properties) associated with the <classname alt="boost::execution_monitor">execution_monitor</classname> instance. All parameters are implemented as public unit_test::readwrite_property data members of the class <classname alt="boost::execution_monitor">execution_monitor</classname>. </para></description><data-member name="p_catch_system_errors"><type>unit_test::readwrite_property&lt; bool &gt;</type><purpose>Should monitor catch system errors. </purpose><description><para>The <emphasis>p_catch_system_errors</emphasis> property is a boolean flag (default value is true) specifying whether or not <classname alt="boost::execution_monitor">execution_monitor</classname> should trap system errors/system level exceptions/signals, which would cause program to crash in a regular case (wihout <classname alt="boost::execution_monitor">execution_monitor</classname>). Set this property to false, for example, if you wish to force coredump file creation. The Unit Test Framework provides a runtime parameter <ndash/>catch_system_errors=yes to alter the behavior in monitored test cases. </para></description></data-member>
<data-member name="p_auto_start_dbg"><type>unit_test::readwrite_property&lt; bool &gt;</type><purpose>Should monitor try to attach debugger in case of caught system error. </purpose><description><para>The <emphasis>p_auto_start_dbg</emphasis> property is a boolean flag (default value is false) specifying whether or not <classname alt="boost::execution_monitor">execution_monitor</classname> should try to attach debugger in case system error is caught. </para></description></data-member>
<data-member name="p_timeout"><type>unit_test::readwrite_property&lt; int &gt;</type><purpose>Specifies the seconds that elapse before a timer_error occurs. </purpose><description><para>The <emphasis>p_timeout</emphasis> property is an integer timeout (in seconds) for monitored function execution. Use this parameter to monitor code with possible deadlocks or indefinite loops. This feature is only available for some operating systems (not yet Microsoft Windows). </para></description></data-member>
<data-member name="p_use_alt_stack"><type>unit_test::readwrite_property&lt; bool &gt;</type><purpose>Should monitor use alternative stack for the signal catching. </purpose><description><para>The <emphasis>p_use_alt_stack</emphasis> property is a boolean flag (default value is false) specifying whether or not <classname alt="boost::execution_monitor">execution_monitor</classname> should use an alternative stack for the sigaction based signal catching. When enabled the signals are delivered to the <classname alt="boost::execution_monitor">execution_monitor</classname> on a stack different from current execution stack, which is safer in case if it is corrupted by monitored function. For more details on alternative stack handling see appropriate manuals. </para></description></data-member>
<data-member name="p_detect_fp_exceptions"><type>unit_test::readwrite_property&lt; unsigned &gt;</type><purpose>Should monitor try to detect hardware floating point exceptions (!= 0), and which specific exception to catch. </purpose><description><para>The <emphasis>p_detect_fp_exceptions</emphasis> property is a boolean flag (default value is false) specifying whether or not <classname alt="boost::execution_monitor">execution_monitor</classname> should install hardware traps for the floating point exception on platforms where it's supported. </para></description></data-member>
<method-group name="public member functions">
<method name="execute"><type>int</type><parameter name="F"><paramtype>boost::function&lt; int()&gt; const &amp;</paramtype><description><para>Function to monitor </para></description></parameter><purpose>Execution monitor entry point for functions returning integer value. </purpose><description><para>This method executes supplied function F inside a try/catch block and also may include other unspecified platform dependent error detection code.</para><para>This method throws an <classname alt="boost::execution_exception">execution_exception</classname> on an uncaught C++ exception, a hardware or software signal, trap, or other user exception.</para><para><note><para>execute() doesn't consider it an error for F to return a non-zero value. </para></note>


<para><emphasis role="bold">See Also:</emphasis><para>vexecute </para></para>
</para></description><returns><para>value returned by function call F(). </para></returns></method>
<method name="vexecute"><type>void</type><parameter name="F"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype><description><para>Function to monitor </para></description></parameter><purpose>Execution monitor entry point for functions returning void. </purpose><description><para>This method is semantically identical to execution_monitor::execute, but des not produce any result code. 
<para><emphasis role="bold">See Also:</emphasis><para>execute </para></para>
</para></description></method>
<method name="register_exception_translator"><type>void</type><template>
          <template-type-parameter name="ExceptionType"><purpose><para>type of the exception we register a translator for </para></purpose></template-type-parameter>
          <template-type-parameter name="ExceptionTranslator"><purpose><para>type of the translator we register for this exception </para></purpose></template-type-parameter>
        </template><parameter name="tr"><paramtype>ExceptionTranslator const &amp;</paramtype><description><para>translator function object with the signature <emphasis> void (ExceptionType const&amp;)</emphasis> </para></description></parameter><parameter name="tag"><paramtype>const_string</paramtype><default>const_string()</default><description><para>tag associated with this translator </para></description></parameter><parameter name=""><paramtype>boost::type&lt; ExceptionType &gt; *</paramtype><default>0</default></parameter><purpose>Registers custom (user supplied) exception translator. </purpose><description><para>This method template registers a translator for an exception type specified as a first template argument. For example <programlisting language="c++">void myExceptTr( MyException const&amp; ex ) { /*do something with the exception here*/}
em.register_exception_translator&lt;MyException&gt;( myExceptTr );
</programlisting> The translator should be any unary function/functor object which accepts MyException const&amp;. This can be free standing function or bound class method. The second argument is an optional string tag you can associate with this translator routine. The only reason to specify the tag is if you plan to erase the translator eventually. This can be usefull in scenario when you reuse the same <classname alt="boost::execution_monitor">execution_monitor</classname> instance to monitor different routines and need to register a translator specific to the routine being monitored. While it is possible to erase the translator based on an exception type it was registered for, tag string provides simpler way of doing this. 

</para></description></method>
<method name="erase_exception_translator"><type>void</type><parameter name="tag"><paramtype>const_string</paramtype><description><para>tag associated with translator you wants to erase </para></description></parameter><purpose>Erases custom exception translator based on a tag. </purpose><description><para>Use the same tag as the one used during translator registration 
</para></description></method>
<method name="erase_exception_translator"><type>void</type><template>
          <template-type-parameter name="ExceptionType"/>
        </template><parameter name=""><paramtype>boost::type&lt; ExceptionType &gt; *</paramtype><default>0</default></parameter><purpose>Erases custom exception translator based on an exception type. </purpose><description><para>tparam ExceptionType Exception type for which you want to erase the translator </para></description></method>
</method-group>
<constructor><purpose>Default constructor initializes all execution monitor properties. </purpose></constructor>
<method-group name="private member functions">
<method name="catch_signals"><type>int</type><parameter name="F"><paramtype>boost::function&lt; int()&gt; const &amp;</paramtype></parameter></method>
</method-group>
</class><class name="execution_aborted"><purpose>This is a trivial default constructible class. Use it to report graceful abortion of a monitored function execution. </purpose></class><class name="system_error"><data-member name="p_errno"><type>unit_test::readonly_property&lt; long &gt;</type></data-member>
<data-member name="p_failed_exp"><type>unit_test::readonly_property&lt; char const * &gt;</type></data-member>
<method-group name="public member functions">
</method-group>
<constructor specifiers="explicit"><parameter name="exp"><paramtype>char const *</paramtype></parameter></constructor>
</class><namespace name="fpe">
<enum name="masks"><enumvalue name="BOOST_FPE_OFF"><default>= 0</default></enumvalue><enumvalue name="BOOST_FPE_DIVBYZERO"><default>= FE_DIVBYZERO</default></enumvalue><enumvalue name="BOOST_FPE_INEXACT"><default>= FE_INEXACT</default></enumvalue><enumvalue name="BOOST_FPE_INVALID"><default>= FE_INVALID</default></enumvalue><enumvalue name="BOOST_FPE_OVERFLOW"><default>= FE_OVERFLOW</default></enumvalue><enumvalue name="BOOST_FPE_UNDERFLOW"><default>= FE_UNDERFLOW</default></enumvalue><enumvalue name="BOOST_FPE_ALL"><default>= FE_ALL_EXCEPT</default></enumvalue><enumvalue name="BOOST_FPE_INV"><default>= BOOST_FPE_ALL+1</default></enumvalue></enum>
<function name="enable"><type>unsigned</type><parameter name="mask"><paramtype>unsigned</paramtype></parameter></function>
<function name="disable"><type>unsigned</type><parameter name="mask"><paramtype>unsigned</paramtype></parameter></function>
</namespace>
</namespace>
<macro name="BOOST_TEST_SYS_ASSERT" kind="functionlike"><macro-parameter name="exp"/></macro>
</header>
<header name="boost/test/framework.hpp">
<para>Defines Unit Test Framework monostate interfaces. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="framework">
<struct name="context_generator"><method-group name="public member functions">
<method name="is_empty" cv="const"><type>bool</type><purpose>Is there any context? </purpose></method>
<method name="next" cv="const"><type>const_string</type><purpose>Give me next frame; empty - last frame. </purpose></method>
</method-group>
<constructor/>
</struct><struct name="internal_error"><inherit access="public">runtime_error</inherit><purpose>This exception type is used to report internal Boost.Test framework errors. </purpose><method-group name="public member functions">
</method-group>
<constructor><parameter name="m"><paramtype>const_string</paramtype></parameter></constructor>
</struct><struct name="setup_error"><inherit access="public">runtime_error</inherit><purpose>This exception type is used to report test module setup errors. </purpose><method-group name="public member functions">
</method-group>
<constructor><parameter name="m"><paramtype>const_string</paramtype></parameter></constructor>
</struct><struct name="test_being_aborted"/><struct name="nothing_to_test"/><namespace name="impl">
<function name="apply_filters"><type>void</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter></function>
</namespace>
<function name="init"><type>void</type><parameter name="init_func"><paramtype>init_unit_test_func</paramtype><description><para>test module initialization routine </para></description></parameter><parameter name="argc"><paramtype>int</paramtype><description><para>command line arguments collection </para></description></parameter><parameter name="argv"><paramtype>char *</paramtype></parameter><purpose>This funcion performs initialization of the framework monostate. </purpose><description><para>It needs to be called every time before the test is started. 
</para></description></function>
<function name="is_initialized"><type>bool</type><purpose>This function tells if the framework monostate is initialized. </purpose></function>
<function name="shutdown"><type>void</type><purpose>This function shuts down the framework and clears up its monostate. </purpose><description><para>It needs to be at the very end of test module execution </para></description></function>
<function name="current_auto_test_suite"><type><classname>test_suite</classname> &amp;</type><parameter name="ts"><paramtype><classname>test_suite</classname> *</paramtype><default>0</default><description><para>test suite to push back to the queue </para></description></parameter><parameter name="push_or_pop"><paramtype>bool</paramtype><default>true</default><description><para>should we push ts to the queue or pop leaf test suite instead </para></description></parameter><purpose>Provides both read and write access to current "leaf" auto test suite during the test unit registration phase. </purpose><description><para>During auto-registration phase the framework maintain a FIFO queue of test units being registered. New test units become children of the current "leaf" test suite and if this is test suite it is pushed back into queue and becomes a new leaf. When test suite registration is completed, a test suite is poped from the back of the queue. Only automatically registered test suites should be added to this queue. Master test suite is always a zero element in this queue, so if no other test suites are registered all test cases are added to master test suite. This function facilitates all three possible actions:<itemizedlist>
<listitem><para>if no argument are provided it returns the current queue leaf test suite</para></listitem><listitem><para>if test suite is provided and no second argument are set, test suite is added to the queue</para></listitem><listitem><para>if no test suite are provided and last argument is false, the semantic of this function is similar to queue pop: last element is popped from the queue 

</para></listitem></itemizedlist>
</para></description></function>
<function name="register_test_unit"><type>void</type><parameter name="tc"><paramtype><classname>test_case</classname> *</paramtype><description><para>test case to register </para></description></parameter><purpose>This function add new test case into the global collection of test units the framework aware of. </purpose><description><para>This function also assignes unique test unit id for every test case. Later on one can use this id to locate the test case if necessary. This is the way for the framework to maintain weak references between test units. 
</para></description></function>
<function name="register_test_unit"><type>void</type><parameter name="ts"><paramtype><classname>test_suite</classname> *</paramtype><description><para>test suite to register </para></description></parameter><purpose>This function add new test suite into the global collection of test units the framework aware of. </purpose><description><para>This function also assignes unique test unit id for every test suite. Later on one can use this id to locate the test case if necessary. This is the way for the framework to maintain weak references between test units. 
</para></description></function>
<function name="deregister_test_unit"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype><description><para>test unit to deregister </para></description></parameter><purpose>This function removes the test unit from the collection of known test units and destroys the test unit object. </purpose><description><para>This function also assignes unique test unit id for every test case. LAter on one can use this id to located the test case if necessary. This is the way for the framework to maintain weak references between test units. 
</para></description></function>
<function name="clear"><type>void</type><purpose>Afer this call the framework can be reinitialized to perform a second test run during the same program lifetime. </purpose></function>
<function name="register_observer"><type>void</type><parameter name="to"><paramtype>test_observer &amp;</paramtype><description><para>test observer object to add </para></description></parameter><purpose>Observer lifetime should exceed the the testing execution timeframe. </purpose><description><para>
</para></description></function>
<function name="deregister_observer"><type>void</type><parameter name="to"><paramtype>test_observer &amp;</paramtype><description><para>test observer object to exclude </para></description></parameter><purpose>Excldes the observer object form the framework's list of test objecrvers. </purpose><description><para>
</para></description></function>
<function name="add_context"><type>int</type><parameter name="context_descr"><paramtype>lazy_ostream const &amp;</paramtype><description><para>context frame message </para></description></parameter><parameter name="sticky"><paramtype>bool</paramtype><description><para>is this sticky frame or not </para></description></parameter><purpose>Records context frame message. </purpose><description><para>Some context frames are sticky - they can only explicetly cleared by specifying context id. Other (non sticky) context frames cleared after every assertion. 

</para></description><returns><para>id of the newly created frame </para></returns></function>
<function name="clear_context"><type>void</type><parameter name="context_id"><paramtype>int</paramtype><default>-1</default></parameter><purpose>Erases context frame (when test exits context scope) </purpose><description><para>If context_id is passed clears that specific context frame identified by this id, otherwise clears all non sticky contexts </para></description></function>
<function name="get_context"><type><classname>context_generator</classname></type><purpose>Produces an instance of small "delegate" object, which facilitates access to collected context. </purpose></function>
<function name="master_test_suite"><type><classname>master_test_suite_t</classname> &amp;</type><purpose>There is only only master test suite per test module. </purpose><description><para>
</para></description><returns><para>a reference the master test suite instance </para></returns></function>
<function name="current_test_case"><type><classname>test_case</classname> const &amp;</type><purpose>This function provides an access to the test case currently being executed. </purpose><description><para>This function is only valid during test execution phase <para><emphasis role="bold">See Also:</emphasis><para>current_test_case_id </para></para>
</para></description></function>
<function name="current_test_case_id"><type>test_unit_id</type><purpose>This function provides an access to an id of the test case currently being executed. </purpose><description><para>This function safer than current_test_case, cause if wont throw if no test case is being executed. <para><emphasis role="bold">See Also:</emphasis><para>current_test_case </para></para>
</para></description></function>
<function name="get"><type><classname>test_unit</classname> &amp;</type><parameter name="tu_id"><paramtype>test_unit_id</paramtype><description><para>id of a test unit to locate </para></description></parameter><parameter name="tu_type"><paramtype>test_unit_type</paramtype><description><para>type of a test unit to locate </para></description></parameter><purpose>This function provides access to a test unit by id and type combination. It will throw if no test unit located. </purpose><description><para>

</para></description><returns><para>located test unit </para></returns></function>
<function name="get"><type>UnitType &amp;</type><template>
          <template-type-parameter name="UnitType"><purpose><para>compile time type of test unit to get (<classname alt="boost::unit_test::test_suite">test_suite</classname> or <classname alt="boost::unit_test::test_case">test_case</classname>) </para></purpose></template-type-parameter>
        </template><parameter name="id"><paramtype>test_unit_id</paramtype><description><para>id of test unit to get </para></description></parameter><purpose>This function template provides access to a typed test unit by id. </purpose><description><para>It will throw if you specify incorrect test unit type 

</para></description></function>
<function name="run"><type>void</type><parameter name="tu"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default><description><para>Optional id of the test unit or test unit itself from which the test is started. If absent, master test suite is used </para></description></parameter><parameter name="continue_test"><paramtype>bool</paramtype><default>true</default><description><para>true == continue test if it was already started, false == restart the test from scratch regardless </para></description></parameter><purpose>Initiates test execution. </purpose><description><para>This function is used to start the test execution from a specific "root" test unit. If no root provided, test is started from master test suite. This second argument facilitates an ability of the test cases to start some other test units (primirilly used internally for self testing) 
</para></description></function>
<function name="run"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> const *</paramtype></parameter><parameter name="continue_test"><paramtype>bool</paramtype><default>true</default></parameter><purpose>Initiates test execution. Same as other overload. </purpose></function>
<function name="assertion_result"><type>void</type><parameter name="ar"><paramtype>unit_test::assertion_result</paramtype></parameter></function>
<function name="exception_caught"><type>void</type><parameter name=""><paramtype><classname>execution_exception</classname> const &amp;</paramtype></parameter><purpose>Reports uncaught exception to all test observers. </purpose></function>
<function name="test_unit_aborted"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Reports aborted test unit to all test observers. </purpose></function>
</namespace>
<typedef name="init_unit_test_func"><purpose>Test module initialization routine signature. </purpose><description><para>Different depending on whether BOOST_TEST_ALTERNATIVE_INIT_API is defined or not </para></description><type><classname>test_suite</classname> *(*</type></typedef>






</namespace>
</namespace>
<macro name="BOOST_TEST_SETUP_ASSERT" kind="functionlike"><macro-parameter name="cond"/><macro-parameter name="msg"/></macro>
</header>
<header name="boost/test/output/compiler_log_formatter.hpp">
<namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class name="compiler_log_formatter"><inherit access="public">boost::unit_test::unit_test_log_formatter</inherit><method-group name="public member functions">
<method name="log_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages to </para></description></parameter><parameter name="test_cases_amount"><paramtype>counter_t</paramtype><description><para>total test case amount to be run </para></description></parameter><purpose>Invoked at the begining of test module execution. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_finish </para></para>
</para></description></method>
<method name="log_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked at the end of test module execution. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_start </para></para>
</para></description></method>
<method name="log_build_info" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework build information is requested. </purpose><description><para>
</para></description></method>
<method name="test_unit_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being started </para></description></parameter><purpose>Invoked when test unit starts (either test suite or test case) </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>test_unit_finish </para></para>
</para></description></method>
<method name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being finished </para></description></parameter><parameter name="elapsed"><paramtype>unsigned long</paramtype><description><para>time in milliseconds spend executing this test unit </para></description></parameter><purpose>Invoked when test unit finishes. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>test_unit_start </para></para>
</para></description></method>
<method name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>skipped test unit </para></description></parameter><purpose>Invoked if test unit skipped for any reason. </purpose><description><para>
</para></description></method>
<method name="log_exception_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="lcd"><paramtype><classname>log_checkpoint_data</classname> const &amp;</paramtype><description><para>information about the last checkpoint before the exception was triggered </para></description></parameter><parameter name="ex"><paramtype><classname>execution_exception</classname> const &amp;</paramtype><description><para>information about the caught exception </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function starts uncaught exception report. It is going to followed by context information. Report is finilized by call to log_exception_finish. 
<para><emphasis role="bold">See Also:</emphasis><para>log_exception_finish </para></para>
</para></description></method>
<method name="log_exception_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function finishes uncaught exception report. 
<para><emphasis role="bold">See Also:</emphasis><para>log_exception_start </para></para>
</para></description></method>
<method name="log_entry_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="led"><paramtype><classname>log_entry_data</classname> const &amp;</paramtype><description><para>log entry attributes </para></description></parameter><parameter name="let"><paramtype>log_entry_types</paramtype><description><para>log entry type log_entry_finish </para></description></parameter><purpose>Invoked by Unit Test Framework to start new log entry. </purpose><description><para>Call to this function starts new log entry. It is followed by series of log_entry_value calls and finally call to log_entry_finish. A log entry may consist of one or more values being reported. Some of these values will be plain strings, while others can be complicated expressions in a form of "lazy" expression template lazy_ostream. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_value, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into. </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>log entry string value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report plain string value. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>lazy_ostream const &amp;</paramtype><description><para>log entry "lazy" value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two ovrloaded methods to report log entry content. This one is used to report some complicated expression passed as an expression template lazy_ostream. In most cases default implementation provided by the framework should work as is (it just converts the lazy expression into a string. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish a log entry report. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_start </para></para>
</para></description></method>
<method name="entry_context_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to start log entry context report. </purpose><description><para>Unit Test Framewrk logs for failed assertons and uncaught exceptions context if one was defined by a test mofule. Context consists of multiple "scopes" identified by description messages assigned by the test module using BOOST_TEST_INFO/BOOST_TEST_CONTEXT statements. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_context, entry_context_finish </para></para>
</para></description></method>
<method name="log_entry_context" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>context "scope" description </para></description></parameter><purpose>Invoked by Unit Test Framework to report log entry context "scope" description. </purpose><description><para>Each "scope" description is reported by separate call to log_entry_context. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, entry_context_finish </para></para>
</para></description></method>
<method name="entry_context_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish log entry context report. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, entry_context_context </para></para>
</para></description></method>
</method-group>
<method-group name="protected member functions">
<method name="print_prefix" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="file"><paramtype>const_string</paramtype></parameter><parameter name="line"><paramtype>std::size_t</paramtype></parameter></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header name="boost/test/output/plain_report_formatter.hpp">
<namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class name="plain_report_formatter"><inherit access="public">boost::unit_test::results_reporter::format</inherit><method-group name="public member functions">
<method name="results_report_start" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="results_report_finish" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="test_unit_report_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="test_unit_report_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="do_confirmation_report" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header name="boost/test/output/xml_log_formatter.hpp">
<namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class name="xml_log_formatter"><inherit access="public">boost::unit_test::unit_test_log_formatter</inherit><method-group name="public member functions">
<method name="log_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages to </para></description></parameter><parameter name="test_cases_amount"><paramtype>counter_t</paramtype><description><para>total test case amount to be run </para></description></parameter><purpose>Invoked at the begining of test module execution. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_finish </para></para>
</para></description></method>
<method name="log_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked at the end of test module execution. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_start </para></para>
</para></description></method>
<method name="log_build_info" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework build information is requested. </purpose><description><para>
</para></description></method>
<method name="test_unit_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being started </para></description></parameter><purpose>Invoked when test unit starts (either test suite or test case) </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>test_unit_finish </para></para>
</para></description></method>
<method name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being finished </para></description></parameter><parameter name="elapsed"><paramtype>unsigned long</paramtype><description><para>time in milliseconds spend executing this test unit </para></description></parameter><purpose>Invoked when test unit finishes. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>test_unit_start </para></para>
</para></description></method>
<method name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>skipped test unit </para></description></parameter><purpose>Invoked if test unit skipped for any reason. </purpose><description><para>
</para></description></method>
<method name="log_exception_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="lcd"><paramtype><classname>log_checkpoint_data</classname> const &amp;</paramtype><description><para>information about the last checkpoint before the exception was triggered </para></description></parameter><parameter name="ex"><paramtype><classname>execution_exception</classname> const &amp;</paramtype><description><para>information about the caught exception </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function starts uncaught exception report. It is going to followed by context information. Report is finilized by call to log_exception_finish. 
<para><emphasis role="bold">See Also:</emphasis><para>log_exception_finish </para></para>
</para></description></method>
<method name="log_exception_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function finishes uncaught exception report. 
<para><emphasis role="bold">See Also:</emphasis><para>log_exception_start </para></para>
</para></description></method>
<method name="log_entry_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="led"><paramtype><classname>log_entry_data</classname> const &amp;</paramtype><description><para>log entry attributes </para></description></parameter><parameter name="let"><paramtype>log_entry_types</paramtype><description><para>log entry type log_entry_finish </para></description></parameter><purpose>Invoked by Unit Test Framework to start new log entry. </purpose><description><para>Call to this function starts new log entry. It is followed by series of log_entry_value calls and finally call to log_entry_finish. A log entry may consist of one or more values being reported. Some of these values will be plain strings, while others can be complicated expressions in a form of "lazy" expression template lazy_ostream. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_value, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into. </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>log entry string value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report plain string value. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish a log entry report. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_start </para></para>
</para></description></method>
<method name="entry_context_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to start log entry context report. </purpose><description><para>Unit Test Framewrk logs for failed assertons and uncaught exceptions context if one was defined by a test mofule. Context consists of multiple "scopes" identified by description messages assigned by the test module using BOOST_TEST_INFO/BOOST_TEST_CONTEXT statements. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_context, entry_context_finish </para></para>
</para></description></method>
<method name="log_entry_context" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>context "scope" description </para></description></parameter><purpose>Invoked by Unit Test Framework to report log entry context "scope" description. </purpose><description><para>Each "scope" description is reported by separate call to log_entry_context. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, entry_context_finish </para></para>
</para></description></method>
<method name="entry_context_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish log entry context report. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, entry_context_context </para></para>
</para></description></method>
<method name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>lazy_ostream const &amp;</paramtype><description><para>log entry "lazy" value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two ovrloaded methods to report log entry content. This one is used to report some complicated expression passed as an expression template lazy_ostream. In most cases default implementation provided by the framework should work as is (it just converts the lazy expression into a string. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_finish </para></para>
</para></description></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header name="boost/test/output/xml_report_formatter.hpp">
<namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class name="xml_report_formatter"><inherit access="public">boost::unit_test::results_reporter::format</inherit><method-group name="public member functions">
<method name="results_report_start" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="results_report_finish" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="test_unit_report_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="test_unit_report_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="do_confirmation_report" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header name="boost/test/parameterized_test.hpp">
<namespace name="boost">
<namespace name="unit_test">
<function name="make_test_case"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="ParamType"/>
          <template-type-parameter name="ParamIter"/>
        </template><parameter name="test_func"><paramtype>boost::function&lt; void(ParamType)&gt; const &amp;</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="par_begin"><paramtype>ParamIter</paramtype></parameter><parameter name="par_end"><paramtype>ParamIter</paramtype></parameter></function>
<function name="make_test_case"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="ParamType"/>
          <template-type-parameter name="ParamIter"/>
        </template><parameter name="test_func"><paramtype>void(*)(ParamType)</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="par_begin"><paramtype>ParamIter</paramtype></parameter><parameter name="par_end"><paramtype>ParamIter</paramtype></parameter></function>
<function name="make_test_case"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="UserTestCase"/>
          <template-type-parameter name="ParamType"/>
          <template-type-parameter name="ParamIter"/>
        </template><parameter name="test_method"><paramtype>void(UserTestCase::*)(ParamType)</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="user_test_case"><paramtype>boost::shared_ptr&lt; UserTestCase &gt; const &amp;</paramtype></parameter><parameter name="par_begin"><paramtype>ParamIter</paramtype></parameter><parameter name="par_end"><paramtype>ParamIter</paramtype></parameter></function>



</namespace>
</namespace>
<macro name="BOOST_PARAM_TEST_CASE" kind="functionlike"><macro-parameter name="function"/><macro-parameter name="begin"/><macro-parameter name="end"/></macro>
<macro name="BOOST_PARAM_CLASS_TEST_CASE" kind="functionlike"><macro-parameter name="function"/><macro-parameter name="tc_instance"/><macro-parameter name="begin"/><macro-parameter name="end"/></macro>
</header>
<header name="boost/test/progress_monitor.hpp">
<para>defines simple text based progress monitor </para><namespace name="boost">
<namespace name="unit_test">
<class name="progress_monitor_t"><inherit access="public">test_observer</inherit><inherit access="public">singleton&lt; progress_monitor_t &gt;</inherit><purpose>This class implements test observer interface and updates test progress as test units finish or get aborted. </purpose></class>





</namespace>
</namespace>
</header>
<header name="boost/test/results_collector.hpp">
<para>defines testing result collector components </para><para>Defines class results_collector_t that is responsible for gathering test results and class test_results for presenting this information to end-user </para><namespace name="boost">
<namespace name="unit_test">
<class name="test_results"><purpose>Collection of attributes constituting test unit results. </purpose><description><para>This class is a collection of attributes describing testing results. The atributes presented as public properties on an instance of the class. In addition summary conclusion methods are presented to generate simple answer to pass/fail question </para></description><data-member name="p_assertions_passed"><type>counter_prop</type></data-member>
<data-member name="p_assertions_failed"><type>counter_prop</type></data-member>
<data-member name="p_warnings_failed"><type>counter_prop</type></data-member>
<data-member name="p_expected_failures"><type>counter_prop</type></data-member>
<data-member name="p_test_cases_passed"><type>counter_prop</type></data-member>
<data-member name="p_test_cases_warned"><type>counter_prop</type></data-member>
<data-member name="p_test_cases_failed"><type>counter_prop</type></data-member>
<data-member name="p_test_cases_skipped"><type>counter_prop</type></data-member>
<data-member name="p_test_cases_aborted"><type>counter_prop</type></data-member>
<data-member name="p_aborted"><type>bool_prop</type></data-member>
<data-member name="p_skipped"><type>bool_prop</type></data-member>
<method-group name="public member functions">
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>counter_t</paramtype></parameter><parameter name=""><paramtype>(<classname>results_collector_t</classname>)(<classname>test_results</classname>)(results_collect_helper)</paramtype></parameter><purpose>Type representing counter like public property. </purpose></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>bool</paramtype></parameter><parameter name=""><paramtype>(<classname>results_collector_t</classname>)(<classname>test_results</classname>)(results_collect_helper)</paramtype></parameter><purpose>Type representing boolean like public property. </purpose></method>
<method name="operator+="><type>void</type><parameter name=""><paramtype><classname>test_results</classname> const &amp;</paramtype></parameter></method>
<method name="clear"><type>void</type></method>
</method-group>
<constructor/>
</class><class name="results_collector_t"><inherit access="public">test_observer</inherit><inherit access="public">singleton&lt; results_collector_t &gt;</inherit><purpose>This class implements test observer interface to collect the result of test unit execution. </purpose><method-group name="public member functions">
<method name="results" cv="const"><type><classname>test_results</classname> const &amp;</type><parameter name="tu_id"><paramtype>test_unit_id</paramtype><description><para>id of a test unit </para></description></parameter><purpose>Results access per test unit. </purpose><description><para>
</para></description></method>
</method-group>
</class>





</namespace>
</namespace>
</header>
<header name="boost/test/results_reporter.hpp">
<para>defines testing result reporter interfaces </para><para>This file defines interfaces that are responsible for results reporting. Interface is presented in a form of free standing function implemented in namespace result_reporter </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="results_reporter">
<class name="format"><purpose>Results report formatter interface. </purpose><description><para>This is abstract interface for the report formatter used by results reporter routines. You can define a custom formatter by implementing this interface and setting the formatter using set_format function. This is usually done during test module initialization </para></description><method-group name="public member functions">
<method name="results_report_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="results_report_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="test_unit_report_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="test_unit_report_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method name="do_confirmation_report" cv="= 0" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
</method-group>
<destructor/>
</class><function name="set_level"><type>void</type><parameter name="l"><paramtype>report_level</paramtype><description><para>report level </para></description></parameter><purpose>Sets reporting level. </purpose><description><para>There are only four possible levels for results report:<itemizedlist>
<listitem><para>confirmation report (boost::unit_test::CONFIRMATION_REPORT). This report level only produces short confirmation message about test module pass/fail status</para></listitem><listitem><para>short report (boost::unit_test::SHORT_REPORT). This report level produces short summary report for failed/passed assertions and test units.</para></listitem><listitem><para>detailed report (boost::unit_test::DETAILED_REPORT). This report level produces detailed report per test unit for passed/failed assertions and uncaught exceptions</para></listitem><listitem><para>no report (boost::unit_test::NO_REPORT). This report level produces no results report. This is used for test modules running as part of some kind of continues integration framework 
</para></listitem></itemizedlist>
</para></description></function>
<function name="set_stream"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><purpose>Sets output stream for results reporting. </purpose><description><para>By default std::cerr is used. Use this function to set a different stream. The framework refers to the stream by reference, so you need to make sure the stream object lifetime exceeds the testing main scope. </para></description></function>
<function name="set_format"><type>void</type><parameter name="of"><paramtype>output_format</paramtype><description><para>one of the presefined enumeration values for output formats </para></description></parameter><purpose>Sets one of the predefined formats. </purpose><description><para>The framework implements two results report formats:<itemizedlist>
<listitem><para>plain human readable format (boost::unit_test::OF_CLF)</para></listitem><listitem><para>XML format (boost::unit_test::OF_XML) 
</para></listitem></itemizedlist>
</para></description></function>
<function name="set_format"><type>void</type><parameter name="f"><paramtype><classname>results_reporter::format</classname> *</paramtype><description><para>pointer to heap allocated instance of custom report formatter class </para></description></parameter><purpose>Sets custom report formatter. </purpose><description><para>The framework takes ownership of the pointer passed as an argument. So this should be a pointer to a heap allocated object 
</para></description></function>
<function name="get_stream"><type>std::ostream &amp;</type><purpose>Access to configured results reporter stream. </purpose><description><para>Use this stream to report additional information abut test module execution </para></description></function>
<function name="make_report"><type>void</type><parameter name="l"><paramtype>report_level</paramtype><default>INV_REPORT_LEVEL</default></parameter><parameter name=""><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
<function name="confirmation_report"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
<function name="short_report"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
<function name="detailed_report"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
</namespace>






</namespace>
</namespace>
</header>
<header name="boost/test/tools/assertion_result.hpp">
<namespace name="boost">
<namespace name="test_tools">
<class name="assertion_result"><purpose>Type used for predicate assertions. </purpose><struct name="dummy"><method-group name="public member functions">
<method name="nonnull"><type>void</type></method>
</method-group>
</struct><method-group name="public member functions">
<method name="operator!" cv="const"><type>bool</type></method>
<method name="conversion-operator" cv="const"><type>safe_bool</type></method>
<method name="BOOST_READONLY_PROPERTY"><type/><parameter name=""><paramtype>bool</paramtype></parameter><parameter name=""><paramtype>(<classname>assertion_result</classname>)</paramtype></parameter></method>
<method name="has_empty_message" cv="const"><type>bool</type></method>
<method name="message"><type>wrap_stringstream &amp;</type></method>
<method name="message" cv="const"><type>const_string</type></method>
</method-group>
<constructor><parameter name="pv_"><paramtype>bool</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="BoolConvertable"/>
        </template><parameter name="pv_"><paramtype>BoolConvertable const &amp;</paramtype></parameter></constructor>
<copy-assignment><type>void</type><parameter name="pv_"><paramtype>bool</paramtype></parameter></copy-assignment>
</class><typedef name="predicate_result"><type><classname>assertion_result</classname></type></typedef>
</namespace>
</namespace>
</header>
<header name="boost/test/tree/test_unit.hpp">
<namespace name="boost">
<namespace name="unit_test">
<class name="test_unit"><enum name="@0"><enumvalue name="type"><default>= TUT_ANY</default></enumvalue></enum>
<typedef name="id_list"><type>std::list&lt; test_unit_id &gt;</type></typedef>
<typedef name="fixture_list"><type>std::list&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef name="decorator_base"><type>decorator::for_test_unit_ptr</type></typedef>
<data-member name="p_type"><type>readonly_property&lt; test_unit_type &gt;</type></data-member>
<data-member name="p_type_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_file_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_line_num"><type>readonly_property&lt; std::size_t &gt;</type></data-member>
<data-member name="p_id"><type>id_t</type></data-member>
<data-member name="p_parent_id"><type>parent_id_t</type></data-member>
<data-member name="p_dependencies"><type>id_list_t</type></data-member>
<data-member name="p_name"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_description"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type></data-member>
<data-member name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type></data-member>
<data-member name="p_enabled" specifiers="mutable"><type>readwrite_property&lt; bool &gt;</type></data-member>
<data-member name="p_decorators"><type>readwrite_property&lt; decorator_base &gt;</type></data-member>
<data-member name="p_fixtures"><type>readwrite_property&lt; fixture_list &gt;</type></data-member>
<method-group name="public member functions">
<method name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method name="check_dependencies" cv="const"><type>bool</type></method>
<method name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>unsigned</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework_impl)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
</method-group>
<method-group name="protected member functions">
</method-group>
<destructor/>
<constructor><parameter name="tu_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="t"><paramtype>test_unit_type</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="module_name"><paramtype>const_string</paramtype></parameter></constructor>
</class><class name="test_unit_generator"><method-group name="public member functions">
<method name="next" cv="const = 0" specifiers="virtual"><type><classname>test_unit</classname> *</type></method>
</method-group>
<method-group name="protected member functions">
</method-group>
<destructor/>
</class><class name="test_case"><inherit access="public">boost::unit_test::test_unit</inherit><enum name="@1"><enumvalue name="type"><default>= TUT_CASE</default></enumvalue></enum>
<enum name="@0"><enumvalue name="type"><default>= TUT_ANY</default></enumvalue></enum>
<typedef name="id_list"><type>std::list&lt; test_unit_id &gt;</type></typedef>
<typedef name="fixture_list"><type>std::list&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef name="decorator_base"><type>decorator::for_test_unit_ptr</type></typedef>
<data-member name="p_test_func"><type>test_func</type></data-member>
<data-member name="p_type"><type>readonly_property&lt; test_unit_type &gt;</type></data-member>
<data-member name="p_type_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_file_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_line_num"><type>readonly_property&lt; std::size_t &gt;</type></data-member>
<data-member name="p_id"><type>id_t</type></data-member>
<data-member name="p_parent_id"><type>parent_id_t</type></data-member>
<data-member name="p_dependencies"><type>id_list_t</type></data-member>
<data-member name="p_name"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_description"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type></data-member>
<data-member name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type></data-member>
<data-member name="p_enabled" specifiers="mutable"><type>readwrite_property&lt; bool &gt;</type></data-member>
<data-member name="p_decorators"><type>readwrite_property&lt; decorator_base &gt;</type></data-member>
<data-member name="p_fixtures"><type>readwrite_property&lt; fixture_list &gt;</type></data-member>
<method-group name="public member functions">
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>boost::function&lt; void()&gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_case</classname>)</paramtype></parameter></method>
<method name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method name="check_dependencies" cv="const"><type>bool</type></method>
<method name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>unsigned</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework_impl)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
</method-group>
<constructor><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="test_func"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype></parameter></constructor>
<constructor><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="test_func"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype></parameter></constructor>
<method-group name="private member functions">
</method-group>
<destructor/>
</class><class name="test_suite"><inherit access="public">boost::unit_test::test_unit</inherit><purpose>Class representing test suites. </purpose><enum name="@2"><enumvalue name="type"><default>= TUT_SUITE</default></enumvalue></enum>
<enum name="@0"><enumvalue name="type"><default>= TUT_ANY</default></enumvalue></enum>
<typedef name="id_list"><type>std::list&lt; test_unit_id &gt;</type></typedef>
<typedef name="fixture_list"><type>std::list&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef name="decorator_base"><type>decorator::for_test_unit_ptr</type></typedef>
<method-group name="public member functions">
<method name="add"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter><parameter name="expected_failures"><paramtype>counter_t</paramtype><default>0</default></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter><purpose>Adds a test unit to a test suite, with possibility to specify the timeout and the expected failures. </purpose></method>
<method name="add"><type>void</type><parameter name="gen"><paramtype><classname>test_unit_generator</classname> const &amp;</paramtype></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter></method>
<method name="remove"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype></parameter><purpose>Removes a test from the test suite. </purpose></method>
<method name="get" cv="const"><type>test_unit_id</type><parameter name="tu_name"><paramtype>const_string</paramtype></parameter></method>
<method name="size" cv="const"><type>std::size_t</type></method>
<method name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method name="check_dependencies" cv="const"><type>bool</type></method>
<method name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>unsigned</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework_impl)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="ts_name"><paramtype>const_string</paramtype></parameter><parameter name="ts_file"><paramtype>const_string</paramtype></parameter><parameter name="ts_line"><paramtype>std::size_t</paramtype></parameter></constructor>
<method-group name="protected member functions">
</method-group>
<constructor specifiers="explicit"><parameter name="module_name"><paramtype>const_string</paramtype></parameter></constructor>
<destructor/>
<data-member name="p_type"><type>readonly_property&lt; test_unit_type &gt;</type></data-member>
<data-member name="p_type_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_file_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_line_num"><type>readonly_property&lt; std::size_t &gt;</type></data-member>
<data-member name="p_id"><type>id_t</type></data-member>
<data-member name="p_parent_id"><type>parent_id_t</type></data-member>
<data-member name="p_dependencies"><type>id_list_t</type></data-member>
<data-member name="p_name"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_description"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type></data-member>
<data-member name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type></data-member>
<data-member name="p_enabled" specifiers="mutable"><type>readwrite_property&lt; bool &gt;</type></data-member>
<data-member name="p_decorators"><type>readwrite_property&lt; decorator_base &gt;</type></data-member>
<data-member name="p_fixtures"><type>readwrite_property&lt; fixture_list &gt;</type></data-member>
</class><class name="master_test_suite_t"><inherit access="public">boost::unit_test::test_suite</inherit><data-member name="argc"><type>int</type></data-member>
<data-member name="argv"><type>char **</type></data-member>
<data-member name="p_type"><type>readonly_property&lt; test_unit_type &gt;</type></data-member>
<data-member name="p_type_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_file_name"><type>readonly_property&lt; const_string &gt;</type></data-member>
<data-member name="p_line_num"><type>readonly_property&lt; std::size_t &gt;</type></data-member>
<data-member name="p_id"><type>id_t</type></data-member>
<data-member name="p_parent_id"><type>parent_id_t</type></data-member>
<data-member name="p_dependencies"><type>id_list_t</type></data-member>
<data-member name="p_name"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_description"><type>readwrite_property&lt; std::string &gt;</type></data-member>
<data-member name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type></data-member>
<data-member name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type></data-member>
<data-member name="p_enabled" specifiers="mutable"><type>readwrite_property&lt; bool &gt;</type></data-member>
<data-member name="p_decorators"><type>readwrite_property&lt; decorator_base &gt;</type></data-member>
<data-member name="p_fixtures"><type>readwrite_property&lt; fixture_list &gt;</type></data-member>
<method-group name="public member functions">
<method name="add"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter><parameter name="expected_failures"><paramtype>counter_t</paramtype><default>0</default></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter><purpose>Adds a test unit to a test suite, with possibility to specify the timeout and the expected failures. </purpose></method>
<method name="add"><type>void</type><parameter name="gen"><paramtype><classname>test_unit_generator</classname> const &amp;</paramtype></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter></method>
<method name="remove"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype></parameter><purpose>Removes a test from the test suite. </purpose></method>
<method name="get" cv="const"><type>test_unit_id</type><parameter name="tu_name"><paramtype>const_string</paramtype></parameter></method>
<method name="size" cv="const"><type>std::size_t</type></method>
<method name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method name="check_dependencies" cv="const"><type>bool</type></method>
<method name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>unsigned</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework_impl)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
</method-group>
<constructor/>
<enum name="@2"><enumvalue name="type"><default>= TUT_SUITE</default></enumvalue></enum>
<enum name="@0"><enumvalue name="type"><default>= TUT_ANY</default></enumvalue></enum>
<typedef name="id_list"><type>std::list&lt; test_unit_id &gt;</type></typedef>
<typedef name="fixture_list"><type>std::list&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef name="decorator_base"><type>decorator::for_test_unit_ptr</type></typedef>
</class>



<function name="make_test_case"><type><classname>test_case</classname> *</type><parameter name="test_func"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter></function>
<function name="make_test_case"><type><classname>test_case</classname> *</type><template>
          <template-type-parameter name="UserTestCase"/>
          <template-type-parameter name="InstanceType"/>
        </template><parameter name="test_method"><paramtype>void(UserTestCase::*)()</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="user_test_case"><paramtype>boost::shared_ptr&lt; InstanceType &gt;</paramtype></parameter></function>
</namespace>
</namespace>
</header>
<header name="boost/test/unit_test.hpp">
<para>Entry point into the Unit Test Framework. </para><para>This header sould be the only header necessary to include to start using the framework </para><namespace name="boost">
<namespace name="unit_test">



<function name="unit_test_main"><type>int</type><parameter name="init_func"><paramtype>init_unit_test_func</paramtype></parameter><parameter name="argc"><paramtype>int</paramtype></parameter><parameter name="argv"><paramtype>char *</paramtype></parameter></function>


</namespace>
</namespace>
<macro name="BOOST_LIB_NAME"/>
</header>
<header name="boost/test/unit_test_log_formatter.hpp">
<para>Defines unit test log formatter interface. </para><para>You can define a class with implements this interface and use an instance of it as a Unit Test Framework log formatter </para><namespace name="boost">
<namespace name="unit_test">
<struct name="log_entry_data"><purpose>Collection of log entry attributes. </purpose><data-member name="m_file_name"><type>std::string</type><purpose>log entry file name </purpose></data-member>
<data-member name="m_line_num"><type>std::size_t</type><purpose>log entry line number </purpose></data-member>
<data-member name="m_level"><type>log_level</type><purpose>log entry level </purpose></data-member>
<method-group name="public member functions">
<method name="clear"><type>void</type></method>
</method-group>
<constructor/>
</struct><struct name="log_checkpoint_data"><purpose>Collection of log checkpoint attributes. </purpose><data-member name="m_file_name"><type>const_string</type><purpose>log checkpoint file name </purpose></data-member>
<data-member name="m_line_num"><type>std::size_t</type><purpose>log checkpoint file name </purpose></data-member>
<data-member name="m_message"><type>std::string</type><purpose>log checkpoint message </purpose></data-member>
<method-group name="public member functions">
<method name="clear"><type>void</type></method>
</method-group>
</struct><class name="unit_test_log_formatter"><purpose>Abstract Unit Test Framework log formatter interface. </purpose><description><para>During the test module execution Unit Test Framework can report messages about success or failure of assertions, which test suites are being run and more (specifically which messages are reported depends on log level threashold selected by the user). All these messages constitute Unit Test Framework log. There are many ways (formats) to present these messages to the user. Boost.Test comes with two formats: "Compiler-like log format" and "XML based log format". Former is intended for human consumption and later is intended for processing by automated regression test systems. If you want to produce some other format you need to implement class with specific interface and use method unit_test_log_t::set_formatter during a test module initialization to set an active formatter. The class <classname alt="boost::unit_test::unit_test_log_formatter">unit_test_log_formatter</classname> defines this interface.</para><para>This interface requires you to format all possible messages being produced in the log. These includes error messages about failed assertions, messages about caught exceptions and information messages about test units being started/ended. All the methods in this interface takes a reference to standard stream as a first argument. This is where final messages needs to be directed to. Also you are givn all the informaion necessary to produce a message. </para></description><enum name="log_entry_types"><enumvalue name="BOOST_UTL_ET_INFO"><purpose>Information message from the framework. </purpose></enumvalue><enumvalue name="BOOST_UTL_ET_MESSAGE"><purpose>Information message from the user. </purpose></enumvalue><enumvalue name="BOOST_UTL_ET_WARNING"><purpose>Warning (non error) condition notification message. </purpose></enumvalue><enumvalue name="BOOST_UTL_ET_ERROR"><purpose>Non fatal error notification message. </purpose></enumvalue><enumvalue name="BOOST_UTL_ET_FATAL_ERROR"><purpose>Fatal error notification message. </purpose></enumvalue><purpose>Types of log entries (messages written into a log) </purpose></enum>
<method-group name="public member functions">
<method name="log_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages to </para></description></parameter><parameter name="test_cases_amount"><paramtype>counter_t</paramtype><description><para>total test case amount to be run </para></description></parameter><purpose>Invoked at the begining of test module execution. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_finish </para></para>
</para></description></method>
<method name="log_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked at the end of test module execution. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_start </para></para>
</para></description></method>
<method name="log_build_info" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework build information is requested. </purpose><description><para>
</para></description></method>
<method name="test_unit_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being started </para></description></parameter><purpose>Invoked when test unit starts (either test suite or test case) </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>test_unit_finish </para></para>
</para></description></method>
<method name="test_unit_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being finished </para></description></parameter><parameter name="elapsed"><paramtype>unsigned long</paramtype><description><para>time in milliseconds spend executing this test unit </para></description></parameter><purpose>Invoked when test unit finishes. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>test_unit_start </para></para>
</para></description></method>
<method name="test_unit_skipped" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>skipped test unit </para></description></parameter><purpose>Invoked if test unit skipped for any reason. </purpose><description><para>
</para></description></method>
<method name="log_exception_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="lcd"><paramtype><classname>log_checkpoint_data</classname> const &amp;</paramtype><description><para>information about the last checkpoint before the exception was triggered </para></description></parameter><parameter name="ex"><paramtype><classname>execution_exception</classname> const &amp;</paramtype><description><para>information about the caught exception </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function starts uncaught exception report. It is going to followed by context information. Report is finilized by call to log_exception_finish. 
<para><emphasis role="bold">See Also:</emphasis><para>log_exception_finish </para></para>
</para></description></method>
<method name="log_exception_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function finishes uncaught exception report. 
<para><emphasis role="bold">See Also:</emphasis><para>log_exception_start </para></para>
</para></description></method>
<method name="log_entry_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="led"><paramtype><classname>log_entry_data</classname> const &amp;</paramtype><description><para>log entry attributes </para></description></parameter><parameter name="let"><paramtype>log_entry_types</paramtype><description><para>log entry type log_entry_finish </para></description></parameter><purpose>Invoked by Unit Test Framework to start new log entry. </purpose><description><para>Call to this function starts new log entry. It is followed by series of log_entry_value calls and finally call to log_entry_finish. A log entry may consist of one or more values being reported. Some of these values will be plain strings, while others can be complicated expressions in a form of "lazy" expression template lazy_ostream. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_value, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_value" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into. </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>log entry string value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report plain string value. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>lazy_ostream const &amp;</paramtype><description><para>log entry "lazy" value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two ovrloaded methods to report log entry content. This one is used to report some complicated expression passed as an expression template lazy_ostream. In most cases default implementation provided by the framework should work as is (it just converts the lazy expression into a string. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_finish </para></para>
</para></description></method>
<method name="log_entry_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish a log entry report. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, log_entry_start </para></para>
</para></description></method>
<method name="entry_context_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to start log entry context report. </purpose><description><para>Unit Test Framewrk logs for failed assertons and uncaught exceptions context if one was defined by a test mofule. Context consists of multiple "scopes" identified by description messages assigned by the test module using BOOST_TEST_INFO/BOOST_TEST_CONTEXT statements. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_context, entry_context_finish </para></para>
</para></description></method>
<method name="log_entry_context" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>context "scope" description </para></description></parameter><purpose>Invoked by Unit Test Framework to report log entry context "scope" description. </purpose><description><para>Each "scope" description is reported by separate call to log_entry_context. 
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, entry_context_finish </para></para>
</para></description></method>
<method name="entry_context_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish log entry context report. </purpose><description><para>
<para><emphasis role="bold">See Also:</emphasis><para>log_entry_start, entry_context_context </para></para>
</para></description></method>
</method-group>
<destructor/>
</class>





</namespace>
</namespace>
</header>
</library-reference>
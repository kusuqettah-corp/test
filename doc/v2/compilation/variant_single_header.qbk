[section:single_header_variant The single-header variant of the __UTF__]

If you prefer to avoid the [*standalone library compilation], you [/ <link linkend="utf.compilation.standalone"> ]
should use the single-header variant of the __UTF__. This variant is implemented, as it follows from its name, in
the single header

``
  #include <boost/test/included/unit_test.hpp>
``

An inclusion of the header causes the complete implementation of the __UTF__ to be included as a part of a test module's
source file. The header ``boost/test/unit_test.hpp`` doesn't have to be
included anymore. You don't have to worry about disabling [*auto-linking] feature either. [/ <link linkend="utf.compilation.auto-linking"> ]
It's done in the implementation header already. This variant
can't be used with the [*multi-file test module]. [/ <xref linkend="multi-file-test-module.def" endterm="multi-file-test-module.def"/>]
Otherwise it's almost identical from the usage prospective to the static library variant of the __UTF__.
In fact the only difference is the name of the include file: ``boost/test/included/unit_test.hpp`` instead of ``boost/test/unit_test.hpp``.


The test runner supplied with this variant requires you to implement the [link ref_test_module test module]
initialization function that matches one of the two specifications depending on the compilation flag
`__BOOST_TEST_ALTERNATIVE_INIT_API__`. If flag isn't defined you are required to
match the original specification. If you define the flag 
`__BOOST_TEST_ALTERNATIVE_INIT_API__` during a test module compilation you are
required to use the alternative initialization function  specification. The __UTF__ provides an ability to
[*automatically generate] an empty test module [/ todo link to autogeneration]
initialization function with correct specification if no custom initialization is required by a test module.

[endsect] [/ single_header_variant]

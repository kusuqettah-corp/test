[/
 / Copyright (c) 2015 Andrzej Krzemienski 
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:decorators Decorators]

Decorators is a mechanism for attaching various pieces of information to test units in a uniform manner. These pieces 
of information affect how the test tree is processed during the execution of the program. They range from test unit 
descriptions to floating-point tolerance or the number of expected failures. They are listed in detail in the following 
sections.

A list of decorators can be associated with a given test case by providing the second argument to macro 
__BOOST_AUTO_TEST_CASE__ or the third argument to macro __BOOST_FIXTURE_TEST_CASE__. Similarly, a list of decorators 
can be associated with a given test suite by providing the second argument to macro __BOOST_AUTO_TEST_SUITE__ or the 
third argument to macro __BOOST_FIXTURE_TEST_SUITE__.

[bt_example decorator_01..Test unit decorators]

Each decorator in the list is preceded by an asterisk (`*`); the subsequent syntax resembles a function call and is 
specified in detail for each decorator. If there is more than one decorator in the list, they are concatenated with no 
additional separator; each asterisk indicates the beginning of a decorator. In the above example, test case `test_case1` 
has one associated ['decorator:] __decorator_label__. This means that when test units are executed selectively by label, 
this test case will match to label `"trivial"`. Test case `test_case2` has three associated decorators: two of type 
`label` and one of type `description`.

[/ ############################]
[section Suite-level decorators]

Similarly, it is possible to apply decorators to test suites. 

[bt_example decorator_02..Test suite decorators]

How a decorator associated with a test suite affects the processing of the test units inside varies with the decorator 
and is described for each decorator in subsequent sections. The meaning of the above example is that when tests are run 
selectively by label, every test unit in suite `suite1` will be run.

It is possible to open a test suite scope more than once in a a translation unit; or to open the same test suite scope 
in multiple translation unit. If this is the case, the total decorator list associated with the test suite is the union 
of decorators specified for each test suite scope opening. This can be illustrated with an example.

[bt_example decorator_03..Decorators on multiple suite openings]

In the above example, the scope of test suite `suite1` is opened three times. This results in a test suite containing 
three test cases and associated with two __decorator_label__ decorators. Therefore running tests by label `"trivial"` 
as well as by label `"simple"` both result in executing all three test cases from the suite.

[caution The above syntax for decorators requires that the compiler supports variadic macros (added in C++11). If you intend for your 
test program to also work for compilers without variadic macros, use explicit decorator syntax, described below.]

[endsect]

[/ ############################]
[section Explicit decorator declaration]

There is another way of associating a decorator set with test units. Macro __BOOST_TEST_DECORATOR__ indicates that its set 
of decorators is to be applied to the test unit or /test case sequence/ that immediately follows the declaration.

[bt_example decorator_00..explicit decorator declaration]

In the above example a decorator is applied to a [link boost_test.tests_organization.test_cases.test_case_generation data-driven test case]. 
Macro __BOOST_DATA_TEST_CASE__ cannot take the decorator set as one of its arguments, therefore the explicit decorator declaration is used. 
Macro __BOOST_DATA_TEST_CASE__ generates a sequence of 4 test cases. The decorator set is applied to each of them.

Another use case for the explicit decorator declaration is when you intend for your test program to compile also on compilers without 
variadic macros. In this case it is recommended that you use the more verbose syntax. 
It is summarized in the following table:

[table
  [[Test unit to register][Concise syntax][Universal syntax]]
  [[test case][```  
BOOST_AUTO_TEST_CASE(test_case, *decor1() *decor2())
{
  // assertions
}
  ```][```
BOOST_TEST_DECORATOR(*decor1() *decor2())
BOOST_AUTO_TEST_CASE(test_case)
{
  // assertions
}
  ```]]
  
  [[test case with fixture][```
BOOST_FIXTURE_TEST_CASE(test_case, Fx, *decor1() *decor2())
{
  // assertions
}
  ```][```
BOOST_TEST_DECORATOR(*decor1() *decor2())
BOOST_FIXTURE_TEST_CASE(test_case, Fx)
{
  // assertions
}
  ```]]
  
  [[test suite][```
BOOST_AUTO_TEST_SUITE(test_suite, *decor1() *decor2())

  // test units

BOOST_AUTO_TEST_SUITE_END()
  ```][```
BOOST_TEST_DECORATOR(*decor1() *decor2())
BOOST_AUTO_TEST_SUITE(test_suite)

  // test units

BOOST_AUTO_TEST_SUITE_END() 
  ```]]
  
[[test suite with fixture][``` 
BOOST_FIXTURE_TEST_SUITE(test_suite, Fx, *decor1() *decor2())

  // test units

BOOST_AUTO_TEST_SUITE_END()
  ```][```
BOOST_TEST_DECORATOR(*decor1() *decor2())
BOOST_FIXTURE_TEST_SUITE(test_suite, Fx)

  // test units

BOOST_AUTO_TEST_SUITE_END() 
  ```]]
  
[[data-driven test case][```
// not doable
  ```][```
BOOST_TEST_DECORATOR(*decor1() *decor2())
BOOST_DATA_TEST_CASE(test_case, data, var)
{
  // assertions
}
  ```]]
  
[[test case template][```
// not doable
  ```][```
BOOST_TEST_DECORATOR(*decor1() *decor2())
__BOOST_AUTO_TEST_CASE_TEMPLATE__(test_case, T, type_list)
{
  // assertions
}
  ```]]
  
[[test case template with fixture][```
// not doable
  ```][```
BOOST_TEST_DECORATOR(*decor1() *decor2())
BOOST_FIXTURE_TEST_CASE_TEMPLATE(test_case, T, type_list, Fx)
{
  // assertions
}
  ```]]
]

Throughout the reminder of this documentation we use only the concise syntax.

[endsect]















[/-----------------------------------------------------------------]


[section:decorator_tolerance tolerance]

``
template <typename FPT>
  tolerance(FPT eps);

template <typename FPT>
  tolerance(test_tools::fpc::percent_tolerance_t<FPT> eps)  
``

Decorator `tolerance` specifies the default comparison tolerance for floating point type `FTP` in the decorated test 
unit. The default tolerance only applies to a particular type, so it makes sense to provide more than one `tolerance` 
decorator if we are comparing different floating point types. For more details see __floating_points_testing_tools__. 
The variant with `percent_tolerance` uses value `eps * .01` as tolerance.

[bt_example decorator_13..decorator tolerance]

In the above example,  in `test1`, checks on `double`s fail because they differ by more what tolerance for `double`s 
specifies. In `test2` the tolerance for `double`s is greater and therefore the checks succeed. In `test3`, we specify 
only tolerance for type `float`, and since the checks use type `double` the specified tolerance does not apply. Tolerance 
in `test4` is equivalent to that in `test1`, therefore its checks also fail. Tolerance in `test5` is equivalent to 
that in `test2`, therefore its checks also succeed.
[endsect] [/ section decorator_tolerance]

[endsect] [/ section decorators]

[/EOF]

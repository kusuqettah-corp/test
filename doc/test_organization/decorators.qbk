[/
 / Copyright (c) 2015 Andrzej Krzemienski 
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[#ref_BOOST_TEST_DECORATOR][section:decorators Decorators]

Decorators provide a way to configure certain aspects of a test unit.

[bt_example example76_decorators..Test unit decorators]

Test unit `test_case1` has one associated ['decorator:] `label`. This means that when test units are executed selectively by label, this test unit will match to label "trivial". Test unit `test_case2` has three associated decorators: two of type `label` and one of type `description`. 

[note Decorators are not available in the [link boost_test.users_guide.usage_variants.single_header single-header variant] of the __UTF__.]

[h3 Suite-level decorators]

It is also possible to decorate test suites. 

[bt_example example77_decorators..Test suite decorators]

The meaning of such decoration is that it applies to every test unit inside the suite. In the case above both tests `suite1/test_case1` and `suite1/test_case2` have tag "trivial".

A decorator applies to every test unit in the suite, even if the scope of a given suite is opened twice:

[bt_example example78_decorators..Decorators on multiple suite openings]

In the above case, both tests `suite1.test_case1` and `suite1/test_case2` have tag "trivial".

In case the scope of the suite is opened twice in the same file with different decorator sets, the last decorator set is in effect:

[bt_example example79_decorators..Different decorators on multiple suite openings]

In the above case, both tests `suite1/test_case1` and `suite1/test_case2` have tag "simple".

In case the scope of the suite is opened twice in two different translation units with different decorator sets, it is unspecified which of the two sets is in effect. This mechanism is tied to the order of initialization of global objects.

[tip It is therefore recommended that you either make sure that each time the test suite scope is opened, it has the same decorator set, or you identify a ['privileged] opening of the suite and decorate it, while keeping all the other openings undecorated.]

[/ ##########################################################################]

[section:available_decorators Available decorators]

[#ref_decorator_label][h3 label]

``
label(const_string label_name);
``

Decorator `label` associates a test unit with label `label_name`. This is useful when one wants to execute test units selectively by label. It is possible to associate more than one label with a test unit.

[bt_example example74_decorators..Decorator label]


[h3 enable_if / disable_if]

``
enable_if(bool condition);
disable_if(bool condition);
``

Decorator `enable_if` disables the test unit from being run if the value of a `condition` evaluates to `false` upon test registration. Decorator `disable_if(c)` behaves the same as `enable_if(!c)`.

[bt_example example75_decorators..Decorator enable_if]


[h3 depends_on]

``
depeneds_on(const_string dependent_test_name);
``

Decorator `depends_on` disables the test unit from being run if the test unit marked as its dependency, is either disabled or is executed and marked as failed. 

[bt_example example70_decorators..Decorator depends_on]

In the above scenario, `test_case2` is not even listed because it is disabled; `test_case5` is not listed because it depends on a disabled test unit. `test_case4` is listed but not executed because it depends on `test_case3`, which failed.


[h3 expected_failures]

``
expected_failures(counter_t number);
``

Decorator `expected_failures` defines the number of expected failures that will be reported upon program execution. At suite level this defines the number of expected failures per suite. The total number of expected failures per suite is the sum of per-suite decorator and per-test decorators inside the suite:

[bt_example example71_decorators..Decorator expected_failures]


[h3 timeout]

``
timeout(unsigned seconds);
``

Decorator `timeout` specifies time (in seconds) that sets the maximum allowed duration of a test unit. If this time is exceeded the test unit is forced to stop and is reported as failure.

[bt_example example72_decorators..Decorator timeout]

[caution Decorator `timeout` has no effect on Windows build. This feature is not implemented on Windows yet.]

[h3 fixture]

``
fixture(const boost::function<void()>& setup, const boost::function<void()>& teardown = {});

template <typename Fx>
  fixture<Fx>();
  
template <typename Fx, typename Arg>
  fixture<Fx>(const Arg& arg);
``

Decorator `fixture` specifies a pair of functions (like `set_up` and `tear_down`) to be called before and after the corresponding test unit. At the suite level the `set_up` function is called once -- before the suite execution starts and `tear_down` function is called once -- after the suite execution ends. It comes in three forms. First expects two functions for set-up and tear-down (the second one can be skipped). The second expects a `DefaultConstructible` class. Its default constructor will be used as set-up function and its destructor as a tear-down function. Third requires a class with one-argument public constructor. Argument `arg` is forwarded to the constructor and this is the set-up function, its destructor is the tear-down function. There is no way to get access to the members of these fixtures from within the test unit or test suite.

[bt_example example73_decorators..Decorator fixture]

[endsect] [/ section available_decorators]

[endsect] [/ section decorators]

[/EOF]

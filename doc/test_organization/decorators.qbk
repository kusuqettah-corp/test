[/
 / Copyright (c) 2015 Andrzej Krzemienski 
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[#ref_BOOST_TEST_DECORATOR][section:decorators Decorators]

Decorators provide a way to configure certain aspects of an automatically registered test unit.

[bt_example example70_decorators..Test unit decorators]

Test case `test_case1` has one associated ['decorator:] `label`. This means that when test units are executed selectively by label, this test case will match to label "trivial". Test case `test_case2` has three associated decorators: two of type `label` and one of type `description`. 

[h3 Suite-level decorators]

It is also possible to decorate test suites. 

[bt_example example71_decorators..Test suite decorators]

The meaning of such decoration is that it applies to every test unit inside the suite. In the case above both test cases `suite1/test_case1` and `suite1/test_case2` have tag "trivial".

A decorator applies to every test unit in the suite, even if the scope of a given suite is opened twice:

[bt_example example72_decorators..Decorators on multiple suite openings]

In the above case, both test cases `suite1.test_case1` and `suite1/test_case2` have tag "trivial".

In case the scope of the suite is opened twice in the same file with different decorator sets, the last decorator set is in effect:

[bt_example example73_decorators..Different decorators on multiple suite openings]

In the above case, both test cases `suite1/test_case1` and `suite1/test_case2` have tag "simple". Tag "trivial" has been overwritten.

In case the scope of the suite is opened twice in two different translation units with different decorator sets, it is unspecified which of the two sets is in effect. This mechanism is tied to the order of initialization of global objects.

[tip It is therefore recommended that you either make sure that each time the test suite scope is opened, it has the same decorator set, or you identify a ['privileged] opening of the suite and decorate only it, while keeping all the other openings undecorated.]

[/=================================================================]

[section:decorator_label label]

``
label(const_string label_name);
``

Decorator `label` associates a test unit with label `label_name`. This is useful when one wants to execute test units selectively by label. It is possible to associate more than one label with a test unit. Decorating a test suite with label `L` is equivalent to decorating every test unit inside with `L`.

[bt_example example74_decorators..decorator label]
[endsect] [/ section label]

[/-----------------------------------------------------------------]

[section:decorator_enabled enabled / disabled]

``
enabled();
disabled();
``

Decorator `disabled` indicates that the test unit's __default_run_status__ is ['false]. This means that that test cases inside this test unit will not be run by default, unless otherwise specified. Decorator `enabled` indicates that the test unit's default run status is ['true]. This means that that test cases inside this test unit will be run by default, unless otherwise specified.

[bt_example decorator_04..decorators enabled and disabled]

Syntactically, it is possible to apply both decorators `enabled` and `disabled` to the same test unit. This is reported as set-up error when the test program is run.

[endsect] [/ section:decorator_enabled]

[/-----------------------------------------------------------------]

[section:decorator_enable_if enable_if]

``
template <bool Condition> enable_if();
``

Decorator `enable_if` indicates that the test unit's __default_run_status__ is either ['true] or ['false], depending on the value of `Condition`. This means that that test cases inside this test unit will or will not be run by default. 

[bt_example decorator_05..decorator enable_if]

Decorator `-enable_if<true>()` is equivalent to decorator `-enabled()`. Similarly, `-enable_if<false>()` is equivalent to decorator `-disabled()`. 

[endsect] [/ section enable_if]


[/-----------------------------------------------------------------]

[section:decorator_depends_on depends_on]

``
depeneds_on(const_string dependent_test_name);
``

Decorator `depends_on` associates the decorated test case (call it `B`) with another test case (call it `A`) specified by name. This affects the processing the test tree in two ways. First, test case `A` is ordered to be run before `B`, irrespective of the order in which they were declared or added to the test tree. Second, the execution of `B` is skipped if `A` is either disabled or skipped or is executed and marked as failed. 

[bt_example decorator_08..decorator depends_on]

In the above scenario, test case `test3` is run (and fails) because `s1/test1` has been run and succeeded; `test4` is skipped because `test3` has failed; `test5` is skipped because `s1/test2` is disabled.

[endsect] [/ section decorator_depends_on]

[/-----------------------------------------------------------------]

[section:decorator_precondition precondition]

[def __class_assertion_result__ [classref boost::test_tools::assertion_result test_tools::assertion_result]]
``
typedef boost::function<__class_assertion_result__ (test_unit_id)> predicate_t;

precondition(predicate_t predicate);
``
Decorator `precondition` associates a ['predicate] with a test unit. Before the test unit is executed, the predicate is evaluated with the test unit's ID passed as the argument. If it evaluates to `false`, execution of the test unit is skipped. Skipping the test suite means skipping the execution of every test unit inside.

[bt_example decorator_06..decorator precondition]

In the example above, the user defined a custom predicate `if_either` that evaluates to `true` if at least one of the two specified tests passed. (It assumes that the tests are registered in the specific order.) Test case `test3` has a precondition that at either `test1` or `test2` passed. The precondition is satisfied, therefore `test3` is run (and fails). Test case `test4` has a precondition that either `test2` or `test3` passed. Since they both failed, the precondition is not satisfied, therefore `test4` is skipped.
 
[endsect] [/ section decorator_precondition]

[/-----------------------------------------------------------------]


[section:description description]

``
description(const_string message);
``

Decorator `description` attaches an arbitrary string to the test unit. All strings attached to test units can be displayed when running a test program with parameter __param_list_content__. This can be used for conveying  information from the person who composes the test tree to the person who will be running the test program. Applying more than one decorator `description` to the same test unit means that the two (or more) strings will be concatenated.

[bt_example decorator_07..decorator description]


[endsect] [/ section description]


[/-----------------------------------------------------------------]

[section:expected_failures expected_failures]

``
expected_failures(counter_t number);
``

Decorator `expected_failures` defines the number of expected failures that will be reported upon program execution. At suite level this defines the number of expected failures per suite. The total number of expected failures per suite is the sum of per-suite decorator and per-test decorators inside the suite:

[bt_example example77_decorators..decorator expected_failures]

[endsect] [/ section expected_failures]


[section:timeout timeout]

``
timeout(unsigned seconds);
``

Decorator `timeout` specifies time (in seconds) that sets the maximum allowed duration of a test case. If this time is exceeded the test unit is forced to stop and is reported as failure.

[bt_example example78_decorators..decorator timeout]

Applied at test suite level, this decorator has no effect.

[caution Decorator `timeout` has no effect on Windows build. This feature is not implemented on Windows yet.]

[endsect] [/ section timeout]

[section:fixture fixture]

``
fixture(const boost::function<void()>& setup, const boost::function<void()>& teardown = {});

template <typename Fx>
  fixture<Fx>();
  
template <typename Fx, typename Arg>
  fixture<Fx>(const Arg& arg);
``

Decorator `fixture` specifies a pair of functions (like `set_up` and `tear_down`) to be called before and after the corresponding test unit. At the suite level the `set_up` function is called once -- before the suite execution starts and `tear_down` function is called once -- after the suite execution ends. It comes in three forms. First expects two functions for set-up and tear-down (the second one can be skipped). The second expects a `DefaultConstructible` class. Its default constructor will be used as set-up function and its destructor as a tear-down function. Third requires a class with one-argument public constructor. Argument `arg` is forwarded to the constructor and this is the set-up function, its destructor is the tear-down function. There is no way to get access to the members of these fixtures from within the test case or test suite.

[bt_example example79_decorators..decorator fixture]

[endsect] [/ section fixture]

[/-----------------------------------------------------------------]


[section:description tolerance]

``
template <typename FPT>
  tolerance(FPT eps);

template <typename FPT>
  tolerance(test_tools::fpc::percent_tolerance_t<FPT> eps)  
``

Decorator `tolerance` specifies the default comparison tolerance for floating point type `FTP` in the decorated test unit. The default tolerance only applies to a particular type, so it makes sense to provide more than one `tolerance` decorator if we are comparing different floating point types. For more details see __floating_points_testing_tools__. The variant with `percent_tolerance` uses value `eps * .01` as tolerance.

[bt_example decorator_11..decorator tolerance]

In the above example,  in `test1`, checks on `double`s fail because they differ by more what tolerance for `double`s specifies. In `test2` the tolerance for `double`s is greater and therefore the checks succeed. In `test3`, we specify only tolerance for type `float`, and since the checks use type `double` the specified tolerance does not apply. Tolerance in `test4` is equivalent to that in `test1`, therefore its checks also fail. Tolerance in `test5` is equivalent to that in `test2`, therefore its checks also succeed.
[endsect] [/ section tolerance]

[endsect] [/ section decorators]

[/EOF]
